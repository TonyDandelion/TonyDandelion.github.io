

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;dark&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="知无涯者">
  <meta name="keywords" content="">
  <title>进程同步与进程、线程通信问题 - 代码即艺术</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/monokai.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>代码即艺术</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/introduction/">
                <i class="iconfont icon-map"></i>
                入门
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/404page.html">
                <i class="iconfont icon-heartbeat"></i>
                公益404
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="进程同步与进程、线程通信问题">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-03-31 11:27" pubdate>
        2020年3月31日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      111
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">进程同步与进程、线程通信问题</h1>
            
            <div class="markdown-body">
              <p>操作系统中的进程同步与进程通信</p>
<a id="more"></a>
<h1 id="进程同步机制">进程同步机制</h1>
<h2 id="背景介绍">背景介绍</h2>
<h3 id="多道程序环境">多道程序环境</h3>
<p>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。与之相对应的是单道程序，即在计算机内存中只允许一个的程序运行。</p>
<h3 id="背景介绍-1">背景介绍</h3>
<p>在多道程序环境下，进程是<strong>并发执行</strong>的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p>
<p>而制约关系也分为：直接相互制约（同步）和间接相互制约（互斥）。</p>
<p>直接相互制约关系是指，为了完成某个目而建立的两个或多个进程，这些进程需要在某些位置协调工作次序、需要信息传递而产生的制约关系，<strong>直接相互制约关系是由于进程间的相互合作而引起的。</strong></p>
<p>间接相互制约关系是指当一个进程进入<strong>临界区</strong>使用<strong>临界资源</strong>时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。<strong>间接制约关系是由于进程之间共享临界资源而引起的。</strong></p>
<h3 id="临界资源和临界区">临界资源和临界区</h3>
<p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，<strong>我们把一次仅允许一个进程使用的资源称为临界资源</strong>。许多物理设备都属于临界资源，如打印机等。此外，<strong>如果变量、数据等都可以被若干进程共享，也属于临界资源。</strong> 而<strong>进程用于访问临界资源的代码就被称为临界区</strong>。我们把程序中，临界区之后的代码称为<strong>剩余区</strong>。</p>
<h3 id="互斥和同步">互斥和同步</h3>
<p><strong>互斥</strong>，又称<strong>间接制约关系</strong>，是指系统中的某些共享资源，一次只允许一个线程访问。当一个线程正在访问该临界资源时，其它线程必须等待。</p>
<p><strong>同步</strong>，又称<strong>直接制约关系</strong>，是指多个线程（或进程）为了合作完成任务，必须严格按照规定的某种先后次序来运行。</p>
<h2 id="基本解决方法">基本解决方法</h2>
<h3 id="遵循一让三等待原则">遵循一让三等待原则</h3>
<p><strong>空闲让进</strong>:当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效利用临界资源。</p>
<p><strong>忙则等待</strong>：当已有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程都必须等待，以保证对临界资源的互斥访问。</p>
<p><strong>有限等待</strong>：对要求访问的临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。</p>
<p><strong>让权等待</strong>：当进程不能进入自己的临界区时，应立即释放处理机，以免陷入"忙等"状态</p>
<h3 id="软件同步机制">软件同步机制</h3>
<p>对进程的互斥访问，逻辑上可以分为</p>
<p>1.进入区 加锁，其它进程不能进入</p>
<p>2.临界区 访问临界资源</p>
<p>3.退出区 释放锁，后其它进程可访问</p>
<p>4.剩余区 其他操作</p>
<p><strong>进入区和退出区是负责实现互斥的代码段。</strong>同步算法一般在1和3的位置做文章。</p>
<h4 id="单标志法">单标志法</h4>
<p>思想： 该算法设置一个公用整型变量 <code>turn</code>，用于指示被允许进入临界区的进程编号，比如 <code>turn = 0</code> ，则允许P0进程进入临界区。该算法可确保每次只允许一个进程进入临界区。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># P0进程</span><br><span class="hljs-keyword">while</span> turn != <span class="hljs-number">0</span>:  <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 等待：确认是否能进入临界区，如果turn不等于0就一直循环等待。</span><br>section = <span class="hljs-number">100</span>  <span class="hljs-comment"># 当turn=0时，说明允许P0进入临界区了，就开始使用临界资源 section了。</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 基于临界资源section的一波操作</span><br>turn = <span class="hljs-number">1</span>  <span class="hljs-comment"># 设置turn=1，将临界资源度让给P1进程，P0进程退出临界区</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 剩余区</span><br><br><span class="hljs-comment"># P1进程</span><br><span class="hljs-keyword">while</span> turn != <span class="hljs-number">1</span>:  <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 等待：确认是否能进入临界区，如果turn不等于1就一直循环等待。</span><br>section = <span class="hljs-number">200</span>  <span class="hljs-comment"># 当turn=1时，说明允许P1进入临界区了，就开始使用临界资源 section了。</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 基于临界资源section的一波操作</span><br>turn = <span class="hljs-number">0</span>  <span class="hljs-comment"># 设置turn=0，将临界资源度让给P0进程，P1进程退出临界区</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 剩余区</span><br></code></pre></div></td></tr></table></figure>
<p>两个进程必须交替进入临界区，如果某个进程不再进入临界区了，那么另一个进程也不能再进入临界区（<strong>违背“空闲让进”</strong>）这样很容易造成资源利用的不充分。 例如，P0退出临界区了，turn被改成了1，但是P1一直不进入临界区，不把turn改回成0，P0就永远用不了这个临界资源了。空着但是用不了，就是违背了“空闲让进”原则。</p>
<h4 id="双多标志法先检查">双（多）标志法<font color="red">先</font>检查</h4>
<p>思想：设置了一个数据<code>flags[i]</code>, 如果第i个值为FLASE，则表示第i个进程Pi未进临界区，如果值为TRUE，表示Pi进程进入临界区。</p>
<p>该算法的基本思想是在每一个进程访问临界区资源之前，先查看一下临界资源是否正在被访问，遍历flag，没有任何一个True出现，则代表临界资源没有被访问，当前进程可以进入临界区使用该临界资源。若被访问，即遍历flag出现了True，该进程需等待。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># 等待阶段，查看一下临界资源是否正在被访问。</span><br>	is_occupation = <span class="hljs-literal">False</span> <span class="hljs-comment"># 默认没有被占用</span><br>	<span class="hljs-keyword">for</span> flag <span class="hljs-keyword">in</span> flags:<br>        <span class="hljs-keyword">if</span> flag == <span class="hljs-literal">True</span>:<br>            is_occupation = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_occupation:<br>        <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 跳出while循环</span><br><span class="hljs-comment"># 完成等待，进入临界区。</span><br>flag[i] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 设置进程i的flag为True，防止其他进程使用该临界资源，形成互斥。</span><br>section = <span class="hljs-number">100</span>  <span class="hljs-comment"># 开始使用临界资源 section。</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 基于临界资源section的一波操作</span><br>flag[i] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 设置进程i的flag为False，宣布该临界资源的使用已经结束，Pi进程退出临界区</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 剩余区</span><br><br><span class="hljs-comment"># 其他进程的代码一样</span><br></code></pre></div></td></tr></table></figure>
<p>当 flag 只负责监控两个进程（i和j）的占用情况时，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># pi进程</span><br><span class="hljs-keyword">while</span> flag[j]： <span class="hljs-comment"># 等待，确认另一个进程j没有使用该临界资源  1</span><br><span class="hljs-comment"># 完成等待，进入临界区。</span><br>flag[i] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 设置进程i的flag为True，防止其他进程使用该临界资源，形成互斥。 3</span><br>section = <span class="hljs-number">100</span>  <span class="hljs-comment"># 开始使用临界资源 section。</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 基于临界资源section的一波操作</span><br>flag[i] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 设置进程i的flag为False，宣布该临界资源的使用已经结束，Pi进程退出临界区</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 剩余区</span><br><br><span class="hljs-comment"># pj进程</span><br><span class="hljs-keyword">while</span> flag[i]： <span class="hljs-comment"># 等待，确认另一个进程i没有使用该临界资源  2</span><br><span class="hljs-comment"># 完成等待，进入临界区。</span><br>flag[j] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 设置进程j的flag为True，防止其他进程使用该临界资源，形成互斥。 4</span><br>section = <span class="hljs-number">200</span>  <span class="hljs-comment"># 开始使用临界资源 section。</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 基于临界资源section的一波操作</span><br>flag[j] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 设置进程j的flag为False，宣布该临界资源的使用已经结束，Pj进程退出临界区</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 剩余区</span><br></code></pre></div></td></tr></table></figure>
<p>优点：不需要交替进入，可连续使用；缺点：pi和pj可能同时进入临界区，按序号①②③④执行，会同时进入临界区(<strong>违背”忙则等待</strong>“)。即在检查对方flag之后和切换自己的flag之间有一段时间，结果都检查通过，同时修改了自己的flag，开始使用同一块本应该互斥的共享资源。<strong>这里问题出在检查和修改操作不能一次进行。</strong></p>
<h4 id="双多标志法后检查">双（多）标志法<font color='red'>后</font>检查</h4>
<p>思想： <strong>双（多）标志法<font color="red">先</font>检查</strong>，先检测其他进程对临界资源的占用情况（状态标志），全部为False之后，再置自己标志为True，完成对临界资源的占用。但是，由于在检测和设置这两个步骤之间存在时间差，可能会有另一个进程同样完成检测和设置，这会造成两个进程分别检测后。同时进入临界区。为此，算法三采用先设置自己标志为True，再检测其余进程对临界资源的占用情况，状态，若有任何一个进程的标志为True，即正在使用临界资源，则该进程等待，否则进入临界区，使用该临界资源。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Pi进程</span><br>flag[i] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 设置进程i的flag为True，防止其他进程使用该临界资源，形成互斥。</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># 等待阶段，查看一下临界资源是否正在被访问。</span><br>	is_occupation = <span class="hljs-literal">False</span> <span class="hljs-comment"># 默认没有被占用</span><br>	<span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(flags)):<br>        flag = flags[flag]<br>        <span class="hljs-keyword">if</span> flag == <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> index != i:<br>            is_occupation = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_occupation:<br>        <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 跳出while循环</span><br><span class="hljs-comment"># 完成等待，进入临界区。</span><br>section = <span class="hljs-number">100</span>  <span class="hljs-comment"># 开始使用临界资源 section。</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 基于临界资源section的一波操作</span><br>flag[i] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 设置进程i的flag为False，宣布该临界资源的使用已经结束，Pi进程退出临界区</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 剩余区</span><br><br><span class="hljs-comment"># 其他进程的代码一样</span><br></code></pre></div></td></tr></table></figure>
<p>当 flag 只负责监控两个进程（i和j）的占用情况时，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># pi进程</span><br>flag[i] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 设置进程i的flag为True，防止其他进程使用该临界资源，形成互斥。</span><br><span class="hljs-keyword">while</span> flag[j]： <span class="hljs-comment"># 等待，确认另一个进程j没有使用该临界资源</span><br><span class="hljs-comment"># 完成等待，进入临界区。</span><br>section = <span class="hljs-number">100</span>  <span class="hljs-comment"># 开始使用临界资源 section。</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 基于临界资源section的一波操作</span><br>flag[i] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 设置进程i的flag为False，宣布该临界资源的使用已经结束，Pi进程退出临界区</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 剩余区</span><br><br><span class="hljs-comment"># pj进程</span><br>flag[j] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 设置进程j的flag为True，防止其他进程使用该临界资源，形成互斥。</span><br><span class="hljs-keyword">while</span> flag[i]： <span class="hljs-comment"># 等待，确认另一个进程i没有使用该临界资源</span><br><span class="hljs-comment"># 完成等待，进入临界区。</span><br>section = <span class="hljs-number">200</span>  <span class="hljs-comment"># 开始使用临界资源 section。</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 基于临界资源section的一波操作</span><br>flag[j] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 设置进程j的flag为False，宣布该临界资源的使用已经结束，Pj进程退出临界区</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 剩余区</span><br></code></pre></div></td></tr></table></figure>
<p>评价： 当两个进程几乎同时想要进入临界区时，他们分别将自己的标志值flag设置为TRUE，并且同时检测对方的状态(执行while语句)，发现对方也要进入临界区，两个进程就会互相谦让，结果谁也进不了临界区，违背了<strong>空闲让进</strong>原则，从而导致"饥饿"现象。</p>
<p>#### Peterson's Algorithm</p>
<p>这个算法的关键是，同时使用了 <code>flags</code> 和 <code>turn</code> 两个变量，其中 <code>ture</code> 为共享变量，<strong>任何时刻只有一个值。</strong>每个进程上来就是先向世界宣布自己想访问临界区，但是，虽然这么想，它还是谦虚的认为，这一轮我不抢，让对方先来！即，把turn设置为对方的。<strong>而能让 Pi 空等的条件是，对方真的也想占用该临界资源，且确实是对方的turn。</strong>只要两个条件任何一个不满足，Pi就大方的进入了它的临界区，使用了这个临界资源，用完了就修改自己的状态标志（flags），向其他进程宣布，我用完啦。谢谢大家。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Pi进程</span><br>flag[i] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 设置进程i的flag为True，防止其他进程使用该临界资源，形成互斥。</span><br>turn = j<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># 等待阶段，查看一下临界资源是否正在被访问。</span><br>	is_occupation = <span class="hljs-literal">False</span> <span class="hljs-comment"># 默认没有被占用</span><br>	<span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(flags)):<br>        flag = flags[flag]<br>        <span class="hljs-keyword">if</span> flag == <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> index != i <span class="hljs-keyword">and</span> turn = j:<br>            is_occupation = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_occupation:<br>        <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 跳出while循环</span><br><span class="hljs-comment"># 完成等待，进入临界区。</span><br>section = <span class="hljs-number">100</span>  <span class="hljs-comment"># 开始使用临界资源 section。</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 基于临界资源section的一波操作</span><br>flag[i] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 设置进程i的flag为False，宣布该临界资源的使用已经结束，Pi进程退出临界区</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 剩余区</span><br><br><span class="hljs-comment"># 其他进程的代码一样</span><br></code></pre></div></td></tr></table></figure>
<p>当 flag 只负责监控两个进程（i和j）的占用情况时，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># pi进程</span><br>flag[i] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 设置进程i的flag为True，防止其他进程使用该临界资源，形成互斥。</span><br>turn = j<br><span class="hljs-keyword">while</span> flag[j] <span class="hljs-keyword">and</span> turn == j： <span class="hljs-comment"># j真的想用，且turn是j的，等待</span><br><span class="hljs-comment"># 完成等待，进入临界区。</span><br>section = <span class="hljs-number">100</span>  <span class="hljs-comment"># 开始使用临界资源 section。</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 基于临界资源section的一波操作</span><br>flag[i] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 设置进程i的flag为False，宣布该临界资源的使用已经结束，Pi进程退出临界区</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 剩余区</span><br><br><span class="hljs-comment"># pj进程</span><br>flag[j] = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 设置进程j的flag为True，防止其他进程使用该临界资源，形成互斥。</span><br>turn = i<br><span class="hljs-keyword">while</span> flag[i] <span class="hljs-keyword">and</span> turn == i： <span class="hljs-comment"># i真的想用，且turn是i的，等待</span><br><span class="hljs-comment"># 完成等待，进入临界区。</span><br>section = <span class="hljs-number">200</span>  <span class="hljs-comment"># 开始使用临界资源 section。</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 基于临界资源section的一波操作</span><br>flag[j] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 设置进程j的flag为False，宣布该临界资源的使用已经结束，Pj进程退出临界区</span><br><span class="hljs-meta">... </span> <span class="hljs-comment"># 剩余区</span><br></code></pre></div></td></tr></table></figure>
<p>仔细看，这个和算法三相比，就多了一个绅士的动作，<strong>加一个turn为对方的条件，并且修改了等待的条件。</strong></p>
<p>因此，我们看，饥饿是如何解决的： 首先，两个人都宣布了自己要访问临界区，大家坦陈相待，很酷。又加上一条，承认对方的turn。 OK，很美好。那么判断的时候，需要满足两个条件自己才等待。 算法三中，饥饿发生的情况是：互相检查对方的状态（flags）时，发现对方都为True，<code>flags[i]</code> 和 <code>flags[j]</code> 都是True，就会相互等待，进入饥饿状态。<br />
现在也假设这么干，无疑，<code>flags[i]</code> 和 <code>flags[j]</code> 都是True，<strong>但是turn是共用的</strong>，Pi设置<code>turn=j</code>，让Pj进入这轮，Pj呢，也很绅士，让<code>turn=i</code>，让Pi先行，无论怎样，任何时刻，<code>turn</code> 只能有一个值，要么是 <code>i</code>，要么是 <code>j</code>，<strong>因此，总有一个while的将会结束，因此，不会再有饥饿。</strong>简而言之，利用 <code>flag</code> 解决临界资源的互斥访问，而利用 <code>turn</code> 解决“饥饿”现象。</p>
<h3 id="硬件同步机制">硬件同步机制</h3>
<p>许多计算机提供一些特殊的硬件指令，允许对一个字中的内容进行检查和修改，或者是对两个字的内容进行交换等。 实际上,对临界区进行管理时，可以将标志看做一个锁，初始时，锁打开，“锁开”进入，"锁关"等待。每次进程要进入临界区时，检测锁。打开时，进入；关闭时，等待。</p>
<h4 id="关闭中断">关闭中断</h4>
<p>思想： 在进入临界区之前关闭操作系统中断，直到完成之后才能打开中断。这样，进程在临界区执行期间，计算机系统不响应中断，从而不会引发调度，也就不会打发生进程或者线程切换。</p>
<p><strong>中断是指程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程。</strong> 操作系统是“中断驱动”的；换言之，中断（广义）是激活操作系统的唯一方式，中断有广义和狭义之分，上述中断时指广义的中断。<br />
狭义的中断来源于<strong>处理器之外的中断事件</strong>，即与当前运行指令无关的中断事件，如I/O中断、时钟中断、外部信号中断等 异常（来源于<strong>CPU内部的中断事件</strong>，和狭义共同构成广义的中断）指当前运行指令引起的中断事件，如地址异常、算术异常、处理器硬件故障等 系统异常与硬件无关，系统异常指执行陷入指令而触发系统调用引起的中断事件，如请求设备、请求I/O、创建进程等</p>
<p><strong>缺点：</strong></p>
<ul>
<li>滥用关中断权利可能会导致严重的后果<br />
</li>
<li>关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；<br />
</li>
<li>关中断方法也并不适用于多CPU系统，因为在一个处理机上关中断并不能防止其他进程在其他处理器上执行相同的临界段代码，获得相同的临界资源。</li>
</ul>
<h4 id="test-and-set指令自旋锁机制">Test-and-Set指令（自旋锁机制）</h4>
<p>目的：为了实现保护共享资源，任何时刻只能有一个保持者。即只有一个进程可以获得锁。</p>
<p><strong>互斥锁机制下，如果资源被占用，资源申请者就会进入睡眠状态（即让权等待，要释放处理机）</strong>。</p>
<p><strong>但是对自旋锁机制（Test-and-Set指令），如果资源被占用，资源申请者（进程）会继续一直循环在那里看自旋锁的保持者是否释放了锁（即忙等，不释放处理机和其他资源）。</strong></p>
<p>借助一条硬件指令——"测试并建立"指令TS以实现互斥的方法，TS指令是原子操作（<strong>原子操作在执行的时候是不可中断的</strong>），即执行过程不可分割。用TS指令管理临界区时，为每个临界资源设置一个布尔变量lock，lock初值为FALSE，表示该临界资源空闲。进程在进入临界区之前，首先用TS指令测试lock，如果其值为FALSE，则表示没有进程在临界区内，可以进入，并将TRUE值赋予lock，这等效于关闭临界资源.如果其值为TRUE，<strong>则重复检查，直到占用这个临界资源的进程退出。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">boolean <span class="hljs-title">TS</span> <span class="hljs-params">(boolean *lock)</span></span>&#123;<br>    boolean old;<br>    old = *lock;<br>    *lock = TRUE;<br>    <span class="hljs-keyword">return</span> old;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">while</span> <span class="hljs-title">TS</span><span class="hljs-params">(&amp;lock)</span></span>;<br>临界区<br>lock = <span class="hljs-literal">false</span>;<br></code></pre></div></td></tr></table></figure>
<h4 id="利用swap指令实现互斥">利用Swap指令实现互斥</h4>
<p><strong>swap指令时交换两个字的内容</strong>,也是一个原子操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span> <span class="hljs-params">(boolean *a, boolean *b)</span></span>&#123;<br>    boolean temp;<br>    tamp = *a;  <span class="hljs-comment">// lock</span><br>    *a = *b<br>    *b = temp;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>用Swap指令可以简单有效的实现互斥，方法是<strong>为每一个临界资源设置一个全局的boolean变量lock，其初值为false</strong>，在<strong>每个进程中再利用一个局部变量key</strong>，初值为true。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">key = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(key != <span class="hljs-literal">false</span>);  <span class="hljs-comment">// 等待，直到某一刻，lock为False，代表该临界资源不被占用，此时，key和lock互换，key也变成了false，结束等待，进入临界区。</span><br>	swap(&amp;lock, &amp;key);  <span class="hljs-comment">// 互换 key 和 lock 的值</span><br>... <span class="hljs-comment">// 临界区</span><br>lock = <span class="hljs-literal">false</span>;<br>... <span class="hljs-comment">// 剩余区</span><br></code></pre></div></td></tr></table></figure>
<p><strong>缺点：</strong></p>
<p>当临界资源忙碌时其他访问进程 必须不断测试 处于一种忙等状态 不符合<strong>让权等待</strong> 造成处理机时间的浪费，同时很难用于解决复杂的进程问题。从等待的进程中随机选取可能会会使得有些进程“饥饿”。</p>
<h3 id="信号量机制">信号量机制</h3>
<p>成熟的进程同步机制，被广泛的应用于各种OS中。</p>
<p>信号量机制是一种功能性比较强的机制，可以用来解决互斥与同步的问题。Dijkstra把整形信号量定义为一个用于表示资源数目的整形量 <code>s</code>，这个整形量 <code>s</code> 它只能被两个标准的原语<code>wait(S)</code> 和 <code>Signal(S)</code> 来访问，也可以记做 <strong>“P操作”(通过) 和 “V操作”(释放)</strong>。</p>
<ul>
<li><code>wait()/P()</code> 获取/申请资源，申请不成功，就wait，所以叫做wait函数。</li>
<li><code>signal()/V()</code> 释放资源，</li>
</ul>
<p><code>wait</code> 和 <code>signal</code> 都属于原子操作。<strong>当我们需要利用信号量实现同步时，需要将资源值设置为0。</strong>只有 <code>p(S)</code> 之后，才能 <code>v(S)</code>。<strong>如果要实现互斥的话，则可以将资源值设置为1。</strong>（注：线程间的同步策略，也可以由信号量机制来实现。）</p>
<h4 id="整型信号量">整型信号量</h4>
<blockquote>
<p>使用整形信号量控制，一直处于忙等状态，<strong>未遵循“让权等待” 的原则。</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">wait(S)&#123; <span class="hljs-comment">// P(s) 获取/</span><br>	<span class="hljs-keyword">while</span>(S&lt;=<span class="hljs-number">0</span>);<br>	S‐‐;<br>&#125;<br>signal(S)&#123;  <span class="hljs-comment">// V(s) 释放</span><br>	S++;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>wait</code> 操作中，只要信号量S&lt;=0，就会不断地测试。因此，该机制并<strong>未遵循“让权等待” 的准则</strong>，而是使进程处于“忙等”的状态。</p>
<h4 id="记录型信号量">记录型信号量</h4>
<blockquote>
<p>引入进程链表，实现了让权等待。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> value; <span class="hljs-comment">//资源数量</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">process</span> *<span class="hljs-title">L</span>;</span> <span class="hljs-comment">//进程链表</span><br>&#125; semaphore;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait</span> <span class="hljs-params">(semaphore S)</span> </span>&#123; <span class="hljs-comment">//相当于申请资源</span><br>    S.value‐‐;<br>    <span class="hljs-keyword">if</span>(S.value&lt;<span class="hljs-number">0</span>) &#123;<br>        add <span class="hljs-keyword">this</span> process to S.L;<br>        block (S.L); <span class="hljs-comment">// S.value&lt;0表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，同时放弃处理机。</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signal</span> <span class="hljs-params">(semaphore S)</span> </span>&#123; <span class="hljs-comment">//相当于释放资源</span><br>    S.value++;<br>    <span class="hljs-keyword">if</span>(S.value&lt;=<span class="hljs-number">0</span>)&#123;<br>	    remove a process P from S.L;<br>    	wakeup(P);<span class="hljs-comment">//将第一个等待进程唤醒。</span><br>    &#125;<br>&#125;	<br></code></pre></div></td></tr></table></figure>
<p><strong>记录型信号量是不存在“忙等”现象的进程同步机制。</strong>除了需要一个用于代表资源数目的整型变量 <code>value</code> 外，再增加一个进程链表 <code>L</code> ，用于链接所有等待该资源的进程，<strong>实现了让权等待</strong>。</p>
<h4 id="and型信号量">And型信号量</h4>
<blockquote>
<p>允许一次对多种临界资源的单一个单位的获取</p>
</blockquote>
<p>AND同步机制的基本思想是：<strong>将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源也不分配给它。</strong>亦即，<strong>对若干个临界资源的分配采取原子操作方式</strong>：要么把它所请求的资源全部分配到进程，要么一个也不分配。由死锁理论可知，这样就可避免上述死锁情况的发生。为此，在wait操作中增加了一个“AND”条件，故称为AND型信号量，或者称为同时 wait 操作，即 simultaneous wait，<code>Swait()</code> 和 <code>Ssignal()</code> 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Swait(S1,S2.…, Sn)&#123;<br>	<span class="hljs-keyword">while</span>(TRUE)&#123;<br>		<span class="hljs-keyword">if</span>(Si&gt;=<span class="hljs-number">1</span>&amp;&amp;..…&amp;&amp; Sn&gt;=<span class="hljs-number">1</span>)&#123; <br>			<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++) Si--; <br>			<span class="hljs-keyword">break</span>;<br>         &#125;<br>         <span class="hljs-keyword">else</span>&#123;<br>		 <span class="hljs-comment">// place the process in the waiting queue associated with the first Si found with Sicl, and set the program count of this process to the beginning of Swait operation 将进程置入等待队列，并将该进程的程序指针指向Swait操作的开头。</span><br>	&#125;<br>&#125;<br><br>Ssignal(S1,S2,.…, Sn)&#123;<br>	<span class="hljs-keyword">while</span>(TRUE)&#123;<br>		<span class="hljs-keyword">for</span>(i=l;i&lt;=n;i++)&#123;<br>			Si++; <br>			<span class="hljs-comment">// Remove all the process waiting in the queue associated with Si into the ready queue  将与临界资源Si有关的所有进程移出等待队列，移入就绪队列。</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>从机制的原理来看，And型信号量机制可以解决死锁问题。</p>
<h4 id="信号量集">信号量集</h4>
<blockquote>
<p>允许一次对多种临界资源的多个单位的获取</p>
</blockquote>
<p>在前面所述的记录型信号量机制中，<strong>wait（S）或signal（S）操作仅能对信号量施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait（S）操作，这显然是低效的，甚至会增加死锁的概率。</strong></p>
<p>此外，在有些情况下，为确保系统的安全性，<strong>当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。</strong>因此，当进程申请某类临界资源时，在每次分配之前，都必须测试资源的数量，判断是否大于<strong>可分配的下限值</strong>，决定是否予以分配。</p>
<p>基于上述两点，可以对AND信号量机制加以扩充，对进程所申请的所有资源以及每类资源不同的资源需求量，在一次P、V原语操作中完成申请或释放。<strong>进程对信号量 <span class="math inline">\(S_i\)</span>，的测试值不再是1，而是该资源的分配下限值 <span class="math inline">\(t_i\)</span>，即要求 <span class="math inline">\(S_i \geq t_i\)</span>，否则不予分配。一旦允许分配，进程对该资源的需求值为 <span class="math inline">\(d_i\)</span>，即表示资源占用量，进行 <span class="math inline">\(S_i := S_i-d_i\)</span> 操作，而不是简单的 <span class="math inline">\(S_i := S_i-1\)</span>。</strong>由此形成一般化的“<strong>信号量集</strong>”机制。对应的 <code>Swait</code> 和 <code>Ssignal</code> 格式为： <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Swait(S1, t1, di, ..., Sn, tn, dn);  <span class="hljs-comment">// Si是第i类临界i资源的数量，ti是第i类临界资源可分配的下限值，di是当前进程对第i类临界资源的需求量。</span><br>Ssignal(S1, di, ..., Sn, dn);  <span class="hljs-comment">// 释放该进程占用的所有资源</span><br></code></pre></div></td></tr></table></figure> 信号量集机制和And信号量机制的区别有两点：</p>
<p>1、引入了<strong>可分配的下限值</strong>，当且仅当临界资源数量大于等于该数值时，才得以申请。 2、引入<strong>进程对该资源的需求值</strong>，进程一次性申请该类型临界资源的多个单位。</p>
<h4 id="信号量实现进程互斥">信号量实现进程互斥</h4>
<p>为了使得多个进程能够互斥的访问某临界资源，只需要</p>
<p>为使多个进程能互斥地访问某临界资源，只需为该资源设置一互斥信号量 <code>mutex</code>，并设其初始值为1，<strong>然后将各进程访问该资源的临界区CS（Critical Section）置于 wait(mutex) 和 signal(mutex) 操作之间即可。</strong> 这样，每个欲访问该临界资源的进程在进入临界区之前，都要先对 <code>mutex</code> 执行 <code>waite()/p()</code>，尝试申请这个临界资源，如果该资源此刻未被访问，本次<code>wait()/p()</code> 就必然成功，进程便可以进入自己的临界区，这时若再有其他进程也欲进入自己的临界区，由于对 <code>mutex</code> 执行 <code>wait()/p()</code> 操作必然失败，此时，该进程就会被阻塞，从而保证了对该临界资源的互斥访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">semaphore mutex = <span class="hljs-number">1</span>;                 semaphore mutex = <span class="hljs-number">1</span>;<br>Pa()&#123;                                Pb()&#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;                        	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>		wait(mutex);		            	wait(mutex);<br>		临界区		                          临界区<br>		signal(mutex);                      signal(mutex);<br>		剩余区		                          剩余区<br>	&#125;                                   &#125;<br>&#125;                                    &#125;<br></code></pre></div></td></tr></table></figure>
<p>在使用信号量机制实现互斥时，需要注意，<code>wait(mutex)</code> 和 <code>signal(mutex)</code> 必须成对出现，没有 <code>wait</code>，资源访问不能保证互斥，没有 <code>signal</code>，资源不能被释放。</p>
<h3 id="互斥锁mutex和标志法ts指令信号量机制semaphore的关系">互斥锁（mutex）和标志法、T&amp;S指令、信号量机制（semaphore）的关系</h3>
<h4 id="解释一-semaphore-mutex">解释一 $semaphore mutex $</h4>
<p><strong>互斥锁（英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。[1]</strong></p>
<p>信号量机制是迪杰斯特拉提出来的一种应用广泛的进程同步工具。[2]</p>
<p>信号量机制是一种高级的互斥锁实现形式</p>
<p>单、双标志和Peterson算法以及中断关闭、Test-and-set、Swap是低级的互斥锁实现形式。</p>
<p>[1] <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/互斥锁">互斥锁维基百科</a> [2] 《计算机操作系统（第四版）》汤小丹等 P53</p>
<h4 id="解释二-semaphore-mutex">解释二 $semaphore mutex $</h4>
<p>Mutex 相比信号量增加了所有权的概念，<strong>一只锁住的 Mutex 只能由给它上锁的线程解开，只有系铃人才能解铃。Mutex 的功能也就因而限制在了构造临界区上。</strong></p>
<p>一元信号量则可以由任一线程解开。这样多出来的一份语义，就是解决读者-写者问题的工具。比如某进程读取磁盘并进入睡眠，等待中断读取盘块结束之后来唤醒它。这就是可以祭出一元信号量的一个情景，而 Mutex 是解决不了的。<strong>『信号量』 这个词本身来自火车站的信号灯，其实本来就暗含着一层 『通知』 的含义。</strong></p>
<p><strong>『同步』这个词也可以拆开看，一侧是等待数据的『事件』或者『通知』，一侧是保护数据的 『临界区』。</strong>信号量可以满足这两个功能，但是可以注意到两个功能的应用场景还是蛮大的，有 do one thing and do it best 的空间。linux 内核曾将 semaphore 作为同步原语，后面代码变得较难维护，刷了一把 mutex 变简单了不少还变快了，需要『通知』 的场景则替换为了 completion variable。</p>
<p>[1] <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/47704079">知乎</a></p>
<h3 id="经典的进程同步问题">经典的进程同步问题</h3>
<h4 id="生产者和消费者问题">生产者和消费者问题</h4>
<p>The procedu-consumer problem</p>
<h4 id="哲学家进餐问题">哲学家进餐问题</h4>
<p>The Dinning Philosophers Problem</p>
<h4 id="读者-写者问题">读者-写者问题</h4>
<p>Reader-Writer</p>
<h1 id="进程通讯机制">进程通讯机制</h1>
<h2 id="信号量机制-1">信号量机制</h2>
<p>信号量机制中，整形、记录型等信号量来控制进程 对临界资源的访问，解决互斥和共享问题，本身就是一种特别的进程通信模式。</p>
<h2 id="共享存储器系统shared-memory-system">共享存储器系统（Shared-Memory System）</h2>
<p>在进程通信之间存在一块可以直接访问的共享空间，通过对这片空间进行读写操作实现进程之间的信息交换，需要加锁。（低级通信方式是基于数据结构的共享（变量），高级则是基于存储区。）</p>
<h2 id="管道通信系统pipe">管道通信系统（pipe）</h2>
<p><strong>所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。</strong> 向管道（共享文件）提供输入的发送进程（即写进程）以字符流形式将大量的数据送入管道；而接受管道输出的接收进程（即读进程）则从管道中接收（读）数据。由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。</p>
<p>为了协调双方的通信，管道机制必须提供以下三方面的协调能力： 1、互斥，即当一个进程正在对pipe 执行读/写操作时，其它（另一）进程必须等待。 2、同步，指当写（输入）进程把一定数量（如4KB）的数据写入pipe，便去睡眠等待，直到读（输出）进程取走数据后再把它唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后才将之唤醒。 3、确定对方是否存在，只有确定了对方已存在时才能进行通信。</p>
<p>优点：能有效地传送大量数据</p>
<ul>
<li>无名管道 <strong>我们可以通过 <code>int pipe(int fd[2])</code> 来创建一个无名管道。无名管道只能在具有亲缘关系的进程之间传递信息</strong>，并通过文件描述符 fd 来控制进程的读写操作： <code>fd[0]</code> 为读打开， <code>fd[1]</code> 为写打开。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> fd[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 两个文件描述符</span><br>    <span class="hljs-keyword">pid_t</span> pid;<br>    <span class="hljs-keyword">char</span> buff[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">if</span>(pipe(fd) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 创建管道</span><br>    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Create Pipe Error!\n&quot;</span>);<br>    <span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 创建子进程</span><br>    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Fork Error!\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 父进程</span><br>        close(fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br>        write(fd[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>, <span class="hljs-number">12</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        close(fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭写端</span><br>        read(fd[<span class="hljs-number">0</span>], buff, <span class="hljs-number">20</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buff);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>有名管道(FIFO) <strong>我们可以使用 <code>int mkfifo(const char* pathname, mode_t mode);</code> 来创建 有名管道 在无关进程中直接交换数据。</strong>当我们 <code>open</code> 一个 <code>FIFO</code> 时，没有指定 <code>O_NONBLOCK</code> （默认），只读 <code>open</code> 要阻塞到某个其他进程为写打开 <code>FIFO</code> ，类似的，只写 <code>open</code> 要阻塞到其他进程为读而打开它。如果 <code>open</code> 一个 <code>FIFO</code> 时，指定了 <code>O_NONELOCK</code> ，则只读 <code>open</code> 立即返回。而只写 <code>open</code> 将出错返回 <code>1</code>。如果没有进程为读而打开该 <code>FIFO</code> ，其 <code>errno</code> 置 <code>ENXIO</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// write_fifo.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt; // exit</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt; // O_WRONLY</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt; // time</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> fd;<br>    <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">time_t</span> tp;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am %d process.\n&quot;</span>, getpid()); <span class="hljs-comment">// 说明进程ID</span><br>    <span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;fifo1&quot;</span>, O_WRONLY)) &lt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 以写打开一个FIFO</span><br>        perror(<span class="hljs-string">&quot;Open FIFO Failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ++i)&#123;<br>        time(&amp;tp); <span class="hljs-comment">// 取系统当前时间</span><br>        n=<span class="hljs-built_in">sprintf</span>(buf,<span class="hljs-string">&quot;Process %d&#x27;s time is %s&quot;</span>,getpid(),ctime(&amp;tp));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Send message: %s&quot;</span>, buf); <span class="hljs-comment">// 打印</span><br>        <span class="hljs-keyword">if</span>(write(fd, buf, n+<span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 写入到FIFO中</span><br>            perror(<span class="hljs-string">&quot;Write FIFO Failed&quot;</span>);<br>            close(fd);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">// 休眠1秒</span><br>    &#125;<br>    close(fd); <span class="hljs-comment">// 关闭FIFO文件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// read_fifo.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> fd;<br>    <span class="hljs-keyword">int</span> len;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">if</span>(mkfifo(<span class="hljs-string">&quot;fifo1&quot;</span>, <span class="hljs-number">0666</span>) &lt; <span class="hljs-number">0</span> &amp;&amp; errno!=EEXIST) <span class="hljs-comment">// 创建FIFO管道</span><br>    	perror(<span class="hljs-string">&quot;Create FIFO Failed&quot;</span>);<br>    <span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;fifo1&quot;</span>, O_RDONLY)) &lt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 以读打开FIFO</span><br>        perror(<span class="hljs-string">&quot;Open FIFO Failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span>((len = read(fd, buf, <span class="hljs-number">1024</span>)) &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 读取FIFO管道</span><br>    	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read message: %s&quot;</span>, buf);<br>    close(fd); <span class="hljs-comment">// 关闭FIFO文件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="消息传递系统message-passing-system">消息传递系统（Message Passing System）</h2>
<p>在该机制中，以格式化的消息（message）为通信单位；利用系统为进程提供的两个高级通信原语send和received进行通信，隐藏看通讯的实现细节，对用户是透明的，使用非常方便，<strong>是使用最广泛的进程通信机制。</strong> 根据实现方式不同，可进一步将他们分为两种：</p>
<h3 id="直接通信">直接通信</h3>
<p>指发送进程利用OS提供的发送原语，直接把消息发送给目标进程。并将它挂在目标进程的消息缓冲队列上，目标进程从缓存队列中取得消息。直接通信可以显式调用通信连接命令，请求系统为之建立一条通信链路，在通信完成后拆除链路，主要用于计算机网络中。也可以不显式调用命令建立通道，只利用系统提供的发送命令原语，让系统自动为之建立链路。</p>
<h3 id="间接通信">间接通信</h3>
<p>发送个接收进程，都通过共享中间实体（邮箱）的方式进行消息的发送和接收，完成进程之间的通信。每一个信箱都有唯一一个标识符。发送和接受消息由系统调用实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 格式化数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message_buffer</span>&#123;</span><br>  <span class="hljs-keyword">int</span> sender； <span class="hljs-comment">//发送者进程标识符</span><br>  <span class="hljs-keyword">int</span> size； <span class="hljs-comment">//消息长度</span><br>  <span class="hljs-keyword">char</span> *text; /消息正文<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">message_buffer</span> *<span class="hljs-title">next</span>； //指向下一个消息缓冲区的指针</span><br><span class="hljs-class">&#125;</span><br></code></pre></div></td></tr></table></figure>
<h2 id="客户机-服务器系统client-serve-system">客户机-服务器系统（Client-Serve System）</h2>
<p>客户机-服务器系统的实现方法，分为三种形式：套接字、远程过程、远程方法调用。</p>
<h3 id="套接字">套接字</h3>
<p>一个套接字就是有关通信标识类型的数据结构，包含了通信目的地，通信使用的端口号，通信网络的传输层协议。通常套接字包括两类:</p>
<ul>
<li>基于文件型：通信进程都运行在一台机器的环境中，套接字是基于本地文件系统的支持，一个套接字关联到一个特殊的文件，双方文件基于这个特殊文件进行读写。</li>
<li>基于网络型：这种类型通常采用非对称方法通信，即发送者需要提供接收者的命名。通信双方的进程运行的在不同主机的网络环境下，被分配了一对套接字。</li>
</ul>
<p>套接字的优势在于，它不仅适用于同一台计算机内部的进程通信，也适用于网络环境中不同计算机间的进程通信。</p>
<h3 id="远程过程和远程方法调用">远程过程和远程方法调用</h3>
<p>远程过程（函数）调用RPC（Remote Procedure Call），<strong>是一个通信协议</strong>，用于通过网络连接的系统。该协议允许运行于一台主机（本地）系统上的进程调用另一台主机（远程）系统上的进程，而对程序员表现为常规的过程调用，无需额外地为此编程。</p>
<h2 id="不同进程通信方法总结">不同进程通信方法总结</h2>
<p>几种通信方法总结综上所述．进程之间的多种通信方法各自有各自的优点和缺点：如果用户传递的信息较少．或是需要通过信号来触发某些行为。信号量机制不失为一种简捷有效的进程间通信方式。</p>
<p>但若是进程间要求传递的信息量比较大或者进程间存在交换数据的要求，那就需要考虑别的通信方式了。无名管道简单方便，但局限于单向通信的工作方式．并且只能在创建它的进程及其子孙进程之间实现管道的共享：有名管道虽然可以提供给任意关系的进程使用．但是由于其长期存在于系统之中，使用不当容易出错．所以普通用户一般不建议使用。</p>
<p>消息队列可以不再局限于父子进程．而允许任意进程通过共享消息队列来实现进程间通信．并由系统调用函数来实现消息发送和接收之间的同步．从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题．使用方便，但是消息队列中信息的复制需要额外消耗CPU的时间。不适宜于信息量大或操作频繁的场合。</p>
<p>共享存储针对消息缓冲的缺点改而利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。但是共享存储的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的。因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决。另外，由于内存实体存在于计算机系统中．所以只能由处于同一个计算机系统中的诸进程共享，不方便网络通信。</p>
<p>不同的进程通信方式有不同的优点和缺点。因此，对于不同的应用问题，要根据问题本身的情况来选择进程间的通信方式。</p>
<p>一般来说，进程间的通信根据通信内容可以划分为两种：即控制信息的传送与大批数据传送。有时也把进程间控制信息的交换称为低级通信，而把进程间大批量数据的交换称为高级通信。</p>
<h1 id="线程通信机制">线程通信机制</h1>
<p><strong>互斥量 Synchronized/Lock</strong></p>
<p>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p>
<p><strong>信号量 Semphare</strong></p>
<p>为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p>
<p><strong>等待/通知机制 Wait/Notify</strong></p>
<p>使用wait/notify方法实现线程间通信，要注意以下两点： 1. wait和notify必须配合synchronized关键字使用 2. wait方法释放锁，notify方法不释放锁</p>
<p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%85%A5%E9%97%A8/">计算机科学入门</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/03/31/somewhere-vs-anywhere/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">somewhere vs anywhere</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/03/31/Python%E5%8D%8F%E7%A8%8B%E7%BC%96%E7%A8%8B/">
                        <span class="hidden-mobile">Python协程编程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function() {
        this.page.url = 'http://example.com/2020/03/31/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98/';
        this.page.identifier = '/2020/03/31/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98/';
      };
      Fluid.utils.waitElementVisible('disqus_thread', function () {
        var d = document, s = d.createElement('script');
        s.src = '//' + 'codesisart' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', new Date());
        (d.head || d.body).appendChild(s);
      });
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>

<!-- <script type="text/javascript" src="/js/cdnjs.cloudflare.com_ajax_libs_mathjax_2.7.1_MathJax.js_config=TeX-MML-AM_CHTML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->


</body>
</html>
