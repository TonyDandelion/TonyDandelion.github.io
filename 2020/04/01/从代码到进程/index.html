

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;dark&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="知无涯者">
  <meta name="keywords" content="">
  <title>从代码到进程 - 代码即艺术</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/monokai.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>代码即艺术</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/introduction/">
                <i class="iconfont icon-map"></i>
                入门
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/404page.html">
                <i class="iconfont icon-heartbeat"></i>
                公益404
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="从代码到进程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-04-01 19:08" pubdate>
        2020年4月1日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      73
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">从代码到进程</h1>
            
            <div class="markdown-body">
              <p><img src="/images/computer.jpg" srcset="/img/loading.gif" alt="o4YBAFrWqa6AY9qWAABbbODkiAc279.png" style="zoom:33%;" /></p>
<p>每天都有无数的程序被编译、部署，不停地跑着，它们干着千奇百怪的事情。如同这个光怪陆离的世界，是由每个人、每个个体组成的，如果我们剖析每个人，会发现他们其实都是一样的结构，都是由细胞、组织组成，再深究便是基因了，DNA里那一个个的“核苷酸基”决定了他们。</p>
<a id="more"></a>
<p>Stay hungry, Stay Foolish!</p>
<h1 id="参考链接">参考链接</h1>
<p><a target="_blank" rel="noopener" href="http://m.elecfans.com/article/663750.html">了解“预编译、编译、汇编、链接”这四个过程对你有很大帮助</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yixinjishu/p/12509203.html">程序的一生：从源程序到进程的辛苦历程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kang___xi/article/details/79571137">从编写源代码到程序在内存中运行的全过程解析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cj_kano/article/details/42374993">从一个可执行文件的生成到进程在内存中分布 （中）/文件到进程的转变</a></p>
<h1 id="从源代码到进程">从源代码到进程</h1>
<p>1、程序员利用高级语言编写源代码（如C++代码 ）。</p>
<p>2、预编译：主要处理源代码文件中的以“#”开头的预编译指令。</p>
<p>3、编译：编译就是把<strong>文本形式源代码</strong>翻译为<strong>机器语言形式的目标文件（模块）</strong>的过程。</p>
<p>4、汇编：将汇编代码转变为及其机器码</p>
<p>5、链接：链接是把<strong>目标文件、操作系统的启动代码和用到的库文件</strong>进行组织形成最终生成一个完整的<strong>装入模块（可执行文件）</strong>的过程。由链接程序将目标模块，以及所需的库函数链接在一起，可执行文件。</p>
<figure>
<img src="https://i.loli.net/2020/04/01/nWlIOPANkhrg2Gs.jpg" srcset="/img/loading.gif" alt="o4YBAFrWqa6AY9qWAABbbODkiAc279.png" /><figcaption aria-hidden="true">o4YBAFrWqa6AY9qWAABbbODkiAc279.png</figcaption>
</figure>
<p>6、装载至内存：操作系统执行可执行文件的过程，就是将完整的装入模块（可执行文件）加载至内存，在内存生成由程序段、数据段、进程控制块（PCB）这三个部分组成的进程实体（进程映像）的过程。在这个过程中需要虚拟内存技术的支持。</p>
<figure>
<img src="https://i.loli.net/2020/04/03/MuST8H9Kina7qCt.png" srcset="/img/loading.gif" alt="Snipaste_2020-04-03_11-28-21.png" /><figcaption aria-hidden="true">Snipaste_2020-04-03_11-28-21.png</figcaption>
</figure>
<p>进程是进程实体的运行过程，系统进行资源分配和调度的一个基本单位。</p>
<p><strong>将源程序变为内存中的可执行程序，需要经过：以上几个步骤，对应的在linux下的命令为：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">gcc -E main.c -o main.i  <span class="hljs-comment"># 预编译，生成main.i文件</span><br>gcc -S main.i            <span class="hljs-comment"># 编译，生成main.S文件</span><br>gcc -c main.S            <span class="hljs-comment"># 汇编，生成main.o文件</span><br>gcc main.o -o main       <span class="hljs-comment"># 链接，生成完整的装入模块/可执行文件</span><br>./main                   <span class="hljs-comment"># 加载(执行)，将完整的装入模块/可执行文件加载至内存，分配虚拟</span><br></code></pre></div></td></tr></table></figure>
<h1 id="基本概念">基本概念</h1>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> gdata1 = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> gdata2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> gdata3;<br> <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> gdata4 = <span class="hljs-number">11</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> gdata5 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> gdata6;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> a = <span class="hljs-number">12</span>;<br>	<span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">int</span> c;<br> <br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> d = <span class="hljs-number">13</span>;<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> e = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> f;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="什么是数据">什么是数据</h2>
<p>大家平时口中经常说程序是由程序代码、数据和进程控制块组成，但是很多人却不知道什么是数据。这里我们搞清楚两件事情，一是什么是数据，二是数据存放在哪里。</p>
<p>(1)、数据 数据指的是<strong>程序中定义的全局变量和静态变量</strong>。还有一种特殊的数据叫做常量。所以上面的的<code>gdata1</code>、<code>gdata2</code>、<code>gdata3</code>、<code>gdata4</code>、<code>gdata5</code>、<code>gdata6</code>、<code>d</code>、<code>e</code> 和 <code>f</code> 均是数据。</p>
<p>(2)、数据存放在哪里 数据存放的区域有三个地方：<code>.data</code> 段、<code>.bss</code> 段 和 <code>.rodata</code> 段。那么你肯定想知道数据是如何放在这三个段中的，怎么区分。</p>
<p>对于<strong>初始化不为0的全局变量和静态变量</strong>存放在 <code>.data</code> 段，即 <code>gdata1</code>、<code>gdata4</code> 和 <code>d</code> 存放在 <code>.data</code> 段。 对于<strong>未初始化或者初始化值为0的段</strong>存放在 <code>.bss</code> 段中，不占目标文件的空间，即<code>gdata2</code>、<code>gdata3</code>、<code>gdata5</code>、<code>gdata6</code>、<code>e</code> 和 <code>f</code> 存放在 <code>.bss</code> 段。 而对于<strong>字符串常量</strong>则存放在 <code>.rodata</code> 段 中，而且对于字符串而言还有一个特殊的地方，就是它在内存中只存在一份。给个代码来测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pStr1 = <span class="hljs-string">&quot;hello,world&quot;</span>;<br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pStr2 = <span class="hljs-string">&quot;hello,world&quot;</span>;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\n&quot;</span>, pStr1);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%x\n&quot;</span>, pStr2);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>可以验证一下，输出的地址肯定是一样的。因为常量字符串 <code>“hello,world”</code> 只存在一份。</p>
<h2 id="什么是指令">什么是指令</h2>
<p>说完了数据，那什么是指令呢？也就是什么是<strong>程序代码</strong>。很简单，<strong>程序中除了数据，剩下的就都是指令了。</strong>这里有一个容易混淆的地方，如下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a+b=%d\n&quot;</span>, a + b);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>大家可能会有一个疑问，就是对于上面的代码，<code>a</code> 和 <code>b</code> 明明是局部变量，难道不是数据吗？嗯，<strong>它真的不是数据，它是一条指</strong>令，<strong>这条指令的功能是在函数的栈帧上开辟四个字节，并向这个地址上写入指定值。</strong></p>
<h2 id="什么是符号">什么是符号</h2>
<p>说完数据和指令，接下来是另一个基础而且重要的概念，那就是符号。我们在编写程序完，进行链接时会碰到这样的错误：<code>错误    LNK1169  找到一个或多个多重定义的符号</code>，即<strong>符号重定义</strong>。那什么是符号，什么东西会产生符号，符号的作用域又是怎样的呢？</p>
<p>在程序中，<strong>所有数据都会产生符号</strong>，而<strong>对于代码段只有函数名会产生符号</strong>。而且符号的作用域有 <code>global</code> 和 <code>local</code> 之分。 对于<strong>未用 <code>static</code> 修饰过的全局变量产生的符号和函数产生的符号均是 <code>global</code> 符号</strong>，这样的变量和函数可以被其他文件所看见和引用。 而<strong>使用 <code>static</code> 修饰过的变量和函数产生的符号</strong>，作用域仅局限于当前文件，不会被其他文件所看见，即其他文件中也无法引用 <code>local</code> 符号的变量和函数。</p>
<p>对于上面的 “找到一个或多个多重定义的符号” 错误原因有可能是多个文件中定义同一个全局变量或函数，即函数名或全局变量名重了。</p>
<h1 id="预编译源代码---替换">预编译（源代码 -&gt; 替换）</h1>
<p><strong>预编译阶段</strong>将根据已放置在文件中的<strong>预处理指令</strong>来<strong>修改源文件的内容</strong>。如<code>#include</code>指令就是一个预处理指令，它把头文件的内容添加到 <code>*.cpp</code> 文件中。预编译提供了很大的灵活性，以适应不同的计算机和操作系统环境的限制。</p>
<p>一个环境需要的代码跟另一个环境所需的代码可能有所不同，因为可用的硬件或操作系统是不同的。在许多情况下，可以把用于不同环境的代码放在同一个文件中，再在预处理阶段修改代码，使之适应当前的环境。</p>
<h2 id="预编译的处理">预编译的处理</h2>
<ul>
<li>宏定义指令，如 <code>#define a b</code></li>
</ul>
<p>对于这种伪指令，预编译所要做的是将程序中的所有a用b替换，但作为字符串常量的 a则不被替换。还有 <code>#undef</code>，则将取消对某个宏的定义，使以后该串的出现不再被替换。</p>
<ul>
<li>条件编译指令，如 <code>#ifdef</code>，<code>#ifndef</code>，<code>#else</code>，<code>#elif</code>，<code>#endif</code> 等。</li>
</ul>
<p>这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理，过滤掉那些不必要的代码。</p>
<ul>
<li>头文件包含指令，如 <code>#include "FileName"</code> 或者 <code>#include</code> 等。</li>
</ul>
<p>头文件中一般用伪指令#define定义了大量的宏（最常见的是字符常量），同时包含有各种外部符号的声明。采用头文件的目的主要是为了使某些定义可以供多个不同的C源程序使用。因为在需要用到这些定义的C源程序中，只需加上一条#include语句即可，而不必再在此文件中将这些定义重复一遍。预编译程序将把头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。</p>
<p>系统提供的头文件，编译器的类库路径里面的头文件，引入格式为 <code>#include &lt;***&gt;</code> 。 程序目录的相对路径中的头文件，引入格式为 <code>#include "***"</code></p>
<ul>
<li>特殊符号，预编译程序可以识别一些特殊的符号。</li>
</ul>
<p>在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。</p>
<h2 id="预编译总结">预编译总结</h2>
<p><strong>预编译程序所完成的基本上是对源程序的“替代”工作。</strong>经过此种替代，生成一个**没有宏定义、没有条件编译指令、没有特殊符号的输出文件（*.i文件）。**这个文件的含义同没有经过预处理的源文件是相同的，但内容有所不同。通过预编译来提供程序员写代码时的方便。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">gcc -E main.c -o main.i  <span class="hljs-comment"># 预编译，生成main.i文件</span><br></code></pre></div></td></tr></table></figure>
<h1 id="编译源代码---汇编代码">编译（源代码 -&gt; 汇编代码）</h1>
<p>经过预编译得到的输出文件中，只有常量；如数字、字符串、变量的定义，以及c语言的关键字，如 <code>main, if, else, for, while, &#123;, &#125;, +, -, *, \</code> 等等。</p>
<p>编译程序所要作得工作就是<strong>通过词法分析和语法分析</strong>，在确认所有的指令都符合语法规则之后，将其翻译成等价的<strong>中间代码表示或汇编代码</strong>。</p>
<p><strong>优化处理是编译系统中一项比较艰深的技术。</strong>它涉及到的问题不仅同编译技术本身有关，而且同机器的硬件环境也有很大的关系。</p>
<p>优化一部分是对中间代码的优化，这种优化不依赖于具体的计算机。主要的工作是删除公共表达式、循环优化（代码外提、强度削弱、变换循环控制条件、已知量的合并等）、复写传播，以及无用赋值的删除，等等。</p>
<p>另一种优化则主要针对目标代码的生成而进行的。同机器的硬件结构密切相关，最主要的是考虑是如何充分利用机器的各个硬件寄存器存放的有关变量的值，以减少对于内存的访问次数。另外，如何根据机器硬件执行指令的特点（如流水线、RISC、CISC、VLIW等）而对指令进行一些调整使目标代码比较短，执行的效率比较高。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">gcc -S main.i            <span class="hljs-comment"># 编译，生成main.S文件</span><br></code></pre></div></td></tr></table></figure>
<h1 id="汇编汇编代码---机器指令文件模块">汇编（汇编代码 -&gt; 机器指令文件/模块）</h1>
<p><strong>汇编实际上指把汇编语言代码翻译成目标机器指令的过程。</strong>对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的<strong>目标文件</strong>。目标文件中所存放的也就是与源程序等效的目标的<strong>机器语言代码/机器指令</strong>。目标文件由段组成，通常<strong>一个目标文件中至少有两个段：</strong> <strong>代码段</strong>：该段中所包含的主要是<strong>程序的指令</strong>。该段一般是可读和可执行的，但一般却不可写。 <strong>数据段</strong>：主要存放<strong>程序中要用到的各种全局变量或静态的数据</strong>。一般数据段都是可读，可写，可执行的。</p>
<p><strong>UNIX环境下主要有三种类型的目标文件</strong></p>
<p>1、可重定位文件 其中包含有<strong>适合于其它目标文件</strong>链接来创建一个<strong>可执行的或者共享的</strong>目标文件的代码和数据。</p>
<p>2、共享的目标文件 这种文件存放了适合于在两种上下文里链接的代码和数据，换而言之，这种文件可以用于两种链接方式。 - 第一种是<strong>链接程序</strong>可把它与<strong>其它可重定位文件及共享的目标文件</strong>一起处理来创建另一个目标文件。（<strong>静态链接方式</strong>） - 第二种是<strong>动态链接程序</strong>将它与<strong>另一个可执行文件及其它的共享目标文件</strong>结合到一起，创建一个进程映象（进程实体）（<strong>动态链接方式</strong>）。</p>
<p>3、可执行文件 它包含了一个可以被操作系统创建一个进程来执行之的文件。</p>
<p><strong><font color="red">汇编程序生成的实际上是第一种类型的目标文件。</font></strong>对于后两种还需要其他的一些处理方能得到，这个就是链接程序的工作了。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">gcc -c main.S            <span class="hljs-comment"># 汇编，生成main.o文件</span><br></code></pre></div></td></tr></table></figure>
<h1 id="链接机器指令文件模块---可执行文件装入模块">链接（机器指令文件/模块 -&gt; 可执行文件/装入模块）</h1>
<p>汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号。或者，在程序中可能调用了某个库文件中的函数，等等。也就是存在跨文件的变量或者函数调用。所有的这些问题，都需要经链接程序的处理方能得以解决。</p>
<p>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，<strong>使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体（可执行文件），又称装入模块（Load Module）。</strong></p>
<p>根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种：</p>
<h2 id="静态链接">静态链接</h2>
<p>在这种链接方式下，<strong>函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。</strong> 这样该程序在被执行时<strong>这些代码将被装入到该进程的虚拟地址空间中</strong>。<strong>静态链接库实际上是一个目标文件的集合，</strong> 其中的每个文件含有库中的一个或者一组相关函数的代码。</p>
<p><strong>静态链接得到的可执行对象，被操作系统执行之后，直接就能创建进程对象。</strong></p>
<h2 id="动态链接">动态链接</h2>
<p>在此种方式下，<strong>函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。</strong>链接程序此时所作的<strong>只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。</strong>在此可执行文件被执行时，动态链接库的全部内容将被<strong>映射到</strong>运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。</p>
<p><strong>静态链接得到的可执行对象，被操作系统执行之后，需要根据可执行程序中记录的信息找到相应的函数代码。</strong></p>
<h2 id="优缺点">优缺点</h2>
<blockquote>
<p>静态链接库</p>
</blockquote>
<p>在链接时，先将目标模块及所需库函数，静态链接库函数lib(Statically-linked <strong>lib</strong>rary)文件和动态链接库函数dll(<strong>D</strong>ynamic <strong>L</strong>inkable <strong>L</strong>ibrary)文件，链接成一个完整的可执行程序（EXE文件），此时的可执行程序是包含复制了一份所需库函数，以后不再拆开。</p>
<p><strong>优点：</strong></p>
<ul>
<li>代码装载速度快，执行速度略比动态链接库快。</li>
<li>只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题</li>
</ul>
<p><strong>缺点：</strong> - 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本。 - 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<figure>
<img src="https://i.loli.net/2020/04/03/b2z9ZXYxDovCiJK.png" srcset="/img/loading.gif" alt="Snipaste_2020-04-03_21-00-06.png" /><figcaption aria-hidden="true">Snipaste_2020-04-03_21-00-06.png</figcaption>
</figure>
<blockquote>
<p>动态链接库</p>
</blockquote>
<p>对于某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行链接。</p>
<p><strong>优点：</strong> - 更加节省内存并减少页面交换。 使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。 - DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性； - 适用于大规模的软件开发，<strong>使开发过程独立、耦合度小，</strong> 便于不同开发者和开发组织之间进行开发和测试。 - 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数。</p>
<p><strong>缺点：</strong> - 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用<strong>载入时动态链接</strong>，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用<strong>运行时动态链接</strong>，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败。 - 速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统死掉。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">gcc main.o -o main       <span class="hljs-comment"># 链接，生成可执行文件，无后缀。</span><br>ld                       <span class="hljs-comment"># 链接</span><br></code></pre></div></td></tr></table></figure>
<h1 id="内存加载">内存加载</h1>
<p>这个阶段涉及了虚拟存储器的工作。 <strong>创建一个进程，然后装载相应的可执行文件（完整的装入模块）并且执行。</strong> 上述过程最开始只需要做三件事情。</p>
<h2 id="分配页目录">分配页目录</h2>
<p>创建一个独立的虚拟地址空间。主要是分配一个<strong>页目录（Page Directory）</strong>，关于页目录详见<a target="_blank" rel="noopener" href="https://onclick.ac.cn/2020/04/02/页面置换算法/#多级分页存储方式">多级分页存储方式</a>。</p>
<h2 id="基于页目录装载相应的可执行文件">基于页目录装载相应的可执行文件</h2>
<p>读取可执行文件的头，并且基于分页存储方式来<strong>建立虚拟空间和可执行文件的映射关系。</strong> 主要是把<strong>可执行文件映射到虚拟地址空间</strong>，即做虚拟页和物理页的映射，以便“缺页”中断产生时载入。</p>
<p><strong>虚拟内存的存储结构</strong></p>
<figure>
<img src="https://i.loli.net/2020/04/06/oT9EN2qKpF5Gn7L.png" srcset="/img/loading.gif" alt="Snipaste_2020-04-06_12-58-09.png" /><figcaption aria-hidden="true">Snipaste_2020-04-06_12-58-09.png</figcaption>
</figure>
<p>前面<a href="#什么是数据">什么是数据</a>说过，一个程序本质上都是由<code>.data</code> 段、<code>.rodata</code>段 和 <code>.bss</code> 段 三个段组成的。一个可执行程序(装入模块)在辅存（没有调入内存）时分为<strong>代码段、已初始数据区（<code>.data</code>段 和 <code>.rodata</code>段 ）和未初始化数据区（<code>.bss</code>段）</strong>三部分。</p>
<p><strong>未初始化数据区</strong>（<code>.bss</code>段）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。<code>.bss</code>段属于静态分配，程序结束后静态变量资源由系统自动释放。<code>.bss</code>段并不占用可执行文件的大小，它是<strong>由链接器来获取内存的</strong>。</p>
<p><strong>已初始化数据区</strong>（<code>.data</code>段 和 <code>.rodata</code>段 ）：存放程序中已初始化的全局变量的一块内存区域，数据段也属于静态内存分配，<code>.data</code>段 和 <code>.rodata</code>段在<strong>编译时已经分配了空间</strong>。</p>
<p>代码段：存放<strong>程序执行代码</strong>的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量。</p>
<p><strong>已初始化数据区</strong>包含经过初始化的全局变量以及它们的值。<strong>未初始化数据区</strong>的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在<strong>已初始化数据区</strong>的后面。<strong>当这个内存进入程序的地址空间后全部清零。</strong> 包含<strong>已初始化数据区</strong>和<strong>未初始化数据区</strong>的整个区段此时通常称为<strong>数据区</strong>。</p>
<p>可执行程序在运行时又多出两个区域：栈区和堆区。</p>
<blockquote>
<p>栈区（系统使用）</p>
</blockquote>
<p>由编译器自动释放，存放<strong>函数的参数值、局部变量</strong>等。每当一个函数被调用时，该函数的<strong>返回类型和一些调用的信息被存放到栈中</strong>。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。<strong>每调用一个函数一个新的栈就会被使用</strong>。<strong>栈区是从高地址位向低地址位增长的</strong>，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p>
<blockquote>
<p>堆区（程序员使用）</p>
</blockquote>
<p>用于动态分配内存，位于<strong>未初始化数据区</strong>和<strong>栈区</strong>中间的地址区域。由程序员申请分配和释放。<strong>堆是从低地址位向高地址位增长</strong>，采用<strong>链式存储结构</strong>，因此<strong>堆的效率比栈要低的多</strong>。频繁的<code>malloc/free</code> 造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。</p>
<h2 id="设置指令寄存器">设置指令寄存器</h2>
<p><strong>将CPU的指令寄存器设置成可执行文件的入口地址</strong>，启动运行。从ELF文件（一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件）中的入口地址开始执行程序。</p>
<blockquote>
<p>到这里，一个源代码经过预编译、编译、汇编、链接、内存加载，在最后一步将CPU指令寄存器设置为该可执行文件的入口地址，就可以开始运行了。</p>
</blockquote>
<h1 id="python程序与c程序执行过程的不同">Python程序与C++程序执行过程的不同</h1>
<blockquote>
<p>编程语言根据执行过程，可以分为3种类型：</p>
</blockquote>
<p>1、<strong>直接编译型编程语言</strong>：编译型语言编译、汇编过程，实际上就是将高级语言翻译成计算机能够直接理解的机器指令文件（机器指令模块），最典型的例子是C++。编译型语言在程序运行之前就已经对程序做出了“翻译”，所以在运行时就少掉了“翻译”的过程，所以效率比较高。一些解释型语言也可以通过解释器的优化来在对程序做出翻译时对整个程序做出优化，从而在效率上超过编译型语言。</p>
<p>2、<strong>直接解释型编程语言</strong>：解释型语言就没有这个编译过程，而是在程序运行的时候，<strong>通过解释器对程序逐行做出解释，<font color='red'>逐行加载，然后运行</font></strong>，最典型的例子是Ruby。</p>
<p>3、<strong>基于虚拟机技术的先编译后解释型编程语言</strong>：先是通过编译器编译成字节码文件，然后在运行时通过解释器（虚拟机）给解释成机器文件。最典型的例子是Java。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">javac hello.java<br>java hello<br></code></pre></div></td></tr></table></figure>
<p>所以我们说Java是一种先编译后解释的语言。</p>
<blockquote>
<p>Python是怎么回事？</p>
</blockquote>
<p><strong>而Python也是一种基于虚拟机的先编译后解释型编程语言</strong>，在说这个问题之前，我们先来说两个概念，<code>PyCodeObject</code> 和 <code>pyc</code> 文件。 我们在硬盘上看到的 <code>pyc</code> 自然不必多说，而其实 <code>PyCodeObject</code> 则是<strong>Python编译器真正编译成的结果</strong>。 当Python<strong>程序第一次运行时</strong>，编译的结果是直接保存在位于内存中的 <code>PyCodeObject</code> ，当Python程序运行结束时，Python解释器则将 <code>PyCodeObject</code> 写回到 <code>pyc</code> 文件中。 当Python程序<strong>第二次运行时</strong>，首先程序会检测源代码是否修改，如果修改了就重新编译，否则就直接在硬盘中寻找对应的 <code>pyc</code> 文件，如果找到，则直接载入，否则就重复第一次运行时的操作。 所以我们应该这样来定位 <code>PyCodeObject</code> 和 <code>pyc</code> 文件：<code>pyc</code> 文件其实是 <code>PyCodeObject</code> 的一种<strong>持久化保存方式。</strong></p>
<p>我们之所以要把 <code>py</code> 文件编译成 <code>pyc</code> 文件，最大的优点在于<strong>我们在运行程序时，不需要重新对该模块进行再次解释。</strong></p>
<p>但是，并非所有的 <code>*.py</code> 文件都会生成 <code>*.pyc</code> 文件，需要编译成 <code>pyc</code> 文件的应该是那些可以重用的模块，这与我们在设计类时是一样的目的。所以Python的解释器认为：只有import进来的模块，才是需要被重用的模块。</p>
<blockquote>
<p>Python检测 <code>py</code> 源码文件是否修改或者 <code>pyc</code> 文件是否过期的具体机制</p>
</blockquote>
<p>在将 <code>PyCodeObject</code> 写入到 <code>pyc</code> 文件的时候，写了一个 <code>Long</code> 型变量，<strong>变量的内容则是对应的 <code>py</code> 文件的最近修改日期</strong>，Python解释器每次在<strong>载入</strong> <code>pyc</code> 文件之前都会检查一下<code>pyc</code> 文件的这个 <code>long</code> 值和 <code>pyc</code> 文件对应的 <code>py</code> 文件最后修改日期是否一致，如果不一致则重新生成新的<code>pyc</code> 文件。</p>
<blockquote>
<p>进一步思考</p>
</blockquote>
<p>其实了解Python程序的执行过程对于大部分程序员来说意义都是不大的，那么真正有意义的是，我们可以从Python解释器的做法上学到一些处理问题的方式和方法：</p>
<p>1、在Python中判断是否生成pyc文件和我们在设计缓存系统时是一样的，我们可以仔细想想，到底什么是值得扔在缓存里面 的，什么是不值得的。 2、在运行一个耗时的Python脚本时，<strong>我们如何能够做到稍微压榨一些程序的运行时间呢？</strong>就是将模块从主模块分开。（虽然往往这都不是瓶颈） 3、在设计一个软件系统时，<strong>重用和非重用的东西是不是也可以分开来对待</strong>，这是软件设计原则的重要部分。 4、在设计缓存系统（或者其他系统）时，我们<strong>如何来避免程序的过期</strong>，其实Python解释器为我们提供了一个特别常见而且有效的解决方案。</p>
<blockquote>
<p>参考链接</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/june_young_fan/article/details/79755392">Python程序的执行过程（解释型语言和编译型语言）</a></p>
<blockquote>
<p>每日一言</p>
</blockquote>
<p>合抱之木，生于毫末；九层之台，起于垒土；千里之行，始于足下。 积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%85%A5%E9%97%A8/">计算机科学入门</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%84%E9%83%A8%E5%88%86%E5%85%B3%E7%B3%BB/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统基础理论思维导图</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/04/01/%E8%AF%B4%E9%81%93%E8%AF%B4%E9%81%93%E6%AD%BB%E9%94%81/">
                        <span class="hidden-mobile">说道说道死锁</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function() {
        this.page.url = 'http://example.com/2020/04/01/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E8%BF%9B%E7%A8%8B/';
        this.page.identifier = '/2020/04/01/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E8%BF%9B%E7%A8%8B/';
      };
      Fluid.utils.waitElementVisible('disqus_thread', function () {
        var d = document, s = d.createElement('script');
        s.src = '//' + 'codesisart' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', new Date());
        (d.head || d.body).appendChild(s);
      });
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>

<!-- <script type="text/javascript" src="/js/cdnjs.cloudflare.com_ajax_libs_mathjax_2.7.1_MathJax.js_config=TeX-MML-AM_CHTML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->


</body>
</html>
