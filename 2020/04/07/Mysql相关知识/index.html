

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;dark&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="知无涯者">
  <meta name="keywords" content="">
  <title>SQL &amp; DBMS &amp; Mysql &amp; Redis 相关知识 - 代码即艺术</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/monokai.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>代码即艺术</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/introduction/">
                <i class="iconfont icon-map"></i>
                入门
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/404page.html">
                <i class="iconfont icon-heartbeat"></i>
                公益404
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="SQL & DBMS & Mysql & Redis 相关知识">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-04-07 11:27" pubdate>
        2020年4月7日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      25.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      298
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">SQL &amp; DBMS &amp; Mysql &amp; Redis 相关知识</h1>
            
            <div class="markdown-body">
              <p><img src="https://i.loli.net/2020/04/08/1ukfrtYvdJCUBaR.jpg" srcset="/img/loading.gif" alt="0_rdg1MHbby7BWV2_d.jpg" style="zoom: 42%;" /></p>
<p>SQL：连接查询与分组查询、连接查询与子查询比较、drop与delete、truncate的比较。 DBMS：ACID、隔离级别、锁机制、MVCC、范式原理、NoSql数据库。 MySq：lnnoDB 与 MyISAM 比较、B+ Tree原理、Mysql索引优化、查询优化。 Redis：使用场景、Memchached比较、集群与分布式、线程安全问题、数据淘汰机制、字典和跳跃表、RDB和AOF持久化机制。</p>
<a id="more"></a>
<h1 id="sql-optimization">SQL Optimization</h1>
<h2 id="连接查询与分组查询">连接查询与分组查询</h2>
<h3 id="linked-query"><strong>Linked query</strong></h3>
<p>所谓的连接查询，就是利用各个表之间的<strong>共同列的关联性</strong>来查询数据。</p>
<p><strong><font color='red'>连接查询是关系型数据库查询最主要的特征。</font></strong></p>
<p>连接查询分为两种类型：</p>
<blockquote>
<p>1、内连接查询（交集）</p>
</blockquote>
<p><strong>内连接查询</strong>是最典型，最常用的连接查询，它根据表中共同的列来进行匹配，特别是两个表存 在主外键关系时通常会使用到内连接查询。</p>
<p>举个栗子，从 <code>student</code> 表和 <code>score</code> 表中查询学生姓名和成绩，<code>id</code> 是 <code>student</code> 表的主键，是 <code>score</code> 表的外键（<code>student.id</code> 和 <code>score.studentID</code> 是同一个值）。</p>
<ul>
<li>基于 <code>=</code> 的内连接查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">select student.sname, score.courseID, score.sscore <br>from student, score <br>where student.id &#x3D; score.studentID <br></code></pre></div></td></tr></table></figure>
<ul>
<li>基于 <code>inner join ... on</code> 的内连接查询，上面的查询语句可以另外写成如下形式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">select student.sname, score.courseID, score.sscore <br>from student as s<br>inner join score as sc<br>on (student.id&#x3D;score.studentID)<br></code></pre></div></td></tr></table></figure>
<p>相当于把上面的 <code>,</code> 改成了 <code>inner join</code>，把 <code>where</code> 改成了 <code>on</code>。</p>
<p><strong>insner join</strong>: 用来连接两个表 <strong>inner</strong>: 可以省略 <strong>on</strong>: 用来设置条件 <strong>as</strong>: 指定表或者列的“别名” ，如果查询的列名在用到两个或多个表中不重复，则对这一列的引用不必用表名来限定。</p>
<blockquote>
<p>2、外连接查询（差集）</p>
</blockquote>
<p><strong>外连接查询</strong>，参与连接的表有主从之分，<strong>以主表的每行数据匹配从表的数据列</strong>，将符合联接条件的数据直接返回到结果集中；对那些不符合连接条件的数据，将被填上 NULL 值（空值）后再返回到结果集中。</p>
<ul>
<li><p>左连接，A,B 表的<strong>交集</strong> 和 <strong>A 表</strong>的数据 （<code>A left join B on A.id=B.id</code>）其中A是主表，如果 A 表中有的数据 B 表没有找到相等的，<strong>会显示所有A表的数据，B表中的部分会为 null 。</strong></p>
<p><em>举个栗子</em>：要统计所有学生的考试情况，要求显示所参加考试学生的每次考试分数，没有参加考试的学生（有这个学生但是没有成绩）也要显示出来，但是数值为null。这时候，<strong>以学生信息表为主表</strong>（有时也叫做左表），学生成绩表为从表，做外连接查询如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> studet.name, score.CourseID, score.sscore<br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> score<br><span class="hljs-keyword">on</span> sudent.id<span class="hljs-operator">=</span>score.studentID<br></code></pre></div></td></tr></table></figure></li>
<li><p>右连接，A,B表的<strong>交集</strong> 和 <strong>B表</strong>的数据（<code>A right join B on A.id=B.id</code>）其中B是主表，如果 B 表中有的数据 A 表没有找到相等的，<strong>会显示所有B表的数据，A表中的部分会为 null 。</strong></p>
<p><em>再举个栗子</em>：要统计所有学生的考试情况，要求显示所参加考试学生的每次考试分数，有成绩但是没有这个学生（旁听生）的记录也要显示出来，但是数值为null。这时候，以学生信息表为从表（有时也叫做左表），<strong>学生成绩表为主表</strong>，做外连接查询如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">select student.name, score.CourseID, score.sscore<br>from student<br>right outer join score<br>on student.id&#x3D;score.studentID<br></code></pre></div></td></tr></table></figure>
<p><code>on</code> 后面还可以有条件，<code>and</code> 或者 <code>where</code>，详情参看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/privategardens/p/10783904.html">SQL 连接（内连接，外连接）</a></p></li>
<li><p>全连接，返回左表和右表中的所有行。当某行在另一表中没有匹配行，则另一表中的列返回空值。AB表的差集之和。</p>
<p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> student.name, score.CourseID, score.sscore<br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">full</span> <span class="hljs-keyword">join</span> score<br><span class="hljs-keyword">on</span> student.id<span class="hljs-operator">=</span>score.studentID<br></code></pre></div></td></tr></table></figure></p></li>
</ul>
<blockquote>
<p>3、交叉连接查询</p>
</blockquote>
<p>我们把 "<strong>没有任何限制条件的连接方式</strong>" 称之为 "交叉连接"，"交叉连接" 后得到的结果跟线性代数中的 "笛卡尔乘积" 一样。使用交叉连接时，任意一张表中的记录多出一行，"交叉连接" 的数量都会增长很多。<a target="_blank" rel="noopener" href="http://www.zsythink.net/archives/1105">参考链接</a></p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> student.name, score.CourseID, score.sscore<br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> score<br></code></pre></div></td></tr></table></figure>
<p>等效于</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> student.name, score.CourseID, score.sscore<br><span class="hljs-keyword">from</span> student, score<br></code></pre></div></td></tr></table></figure>
<p><em>举个栗子</em>：新建 t1 和 t2 两张表格，存入几条数据。 <figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t1;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> tom  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> jack <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> li   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">get</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> post <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br></code></pre></div></td></tr></table></figure> 执行交叉查询 <figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> t2;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+----+------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+----+------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> tom  <span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">get</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> tom  <span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> post <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> jack <span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">get</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> jack <span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> post <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> li   <span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">get</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> li   <span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> post <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+----+------+</span><br><span class="hljs-number">6</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t1,t2;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+----+------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+----+------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> tom  <span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">get</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> tom  <span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> post <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> jack <span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">get</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> jack <span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> post <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> li   <span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">get</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> li   <span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> post <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+----+------+</span><br><span class="hljs-number">6</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br></code></pre></div></td></tr></table></figure> 可以看到，t1有3条记录，t2有2条记录。交叉查询就会有5条记录，就是 <span class="math inline">\(2 \times 3 = 5\)</span>。</p>
<blockquote>
<p>4、总结</p>
</blockquote>
<p>连接查询是关系数据库中最主要的查询，主要包括内连接、外连接和交叉连接等。通过连接运算符可以实现多个表查询。 连接是关系数据库模型的主要特点，也是它区别于其它类型数据库管理系统的一个标志。</p>
<h3 id="group-query"><strong>Group query</strong></h3>
<p>1、使用 <code>group by</code> 关键字进行<strong>单列查询</strong>，<code>group by</code> 后面就<strong>一个关键字</strong>。</p>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">select column_name from table_name group by column_name;<br></code></pre></div></td></tr></table></figure>
<p>举个栗子</p>
<p>查询每个性别的学生人数各是多少？</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">mysql&gt; select * from t2;<br>+----+-------+------+<br>| id | name  | ssex |<br>+----+-------+------+<br>|  1 | sam   |    0 |<br>|  2 | kitty |    1 |<br>|  3 | Laho  |    0 |<br>|  4 | Laho  |    0 |<br>+----+-------+------+<br>4 rows in set (0.00 sec)<br><br>mysql&gt; select ssex,count(*) as &#39;人数&#39; from t2 group by ssex;<br>+------+--------+<br>| ssex | 人数   |<br>+------+--------+<br>|    0 |      3 |<br>|    1 |      1 |<br>+------+--------+<br>2 rows in set (0.00 sec)<br></code></pre></div></td></tr></table></figure>
<p>查询每个科目的平均分，并按照降序（<strong>默认是升序</strong>）排列显示，<code>decs</code> 关键字可以指定降序排列。</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> couseID, <span class="hljs-built_in">avg</span>(score) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;课程平均成绩&#x27;</span> <span class="hljs-keyword">from</span> score <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-built_in">avg</span>(score) decs;<br></code></pre></div></td></tr></table></figure>
<p>2、使用 <code>group by</code> 关键字进行多列查询，<code>group by</code> 后面多个关键字。</p>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">select column_name from table_name group by column_name1, column_name2;<br></code></pre></div></td></tr></table></figure>
<p>举个栗子</p>
<p>查询每个年级、每个性别的学生人数各是多少？</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------+------+-------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name  <span class="hljs-operator">|</span> ssex <span class="hljs-operator">|</span> grade <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------+------+-------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> sam   <span class="hljs-operator">|</span>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> kitty <span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> Laho  <span class="hljs-operator">|</span>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> Laho  <span class="hljs-operator">|</span>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> kaka  <span class="hljs-operator">|</span>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------+------+-------+</span><br><span class="hljs-number">5</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> grade <span class="hljs-keyword">as</span> 年级, ssex <span class="hljs-keyword">as</span> 性别, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> 人数 <span class="hljs-keyword">from</span> t2 <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> grade, ssex <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> grade;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+--------+--------+</span><br><span class="hljs-operator">|</span> 年级   <span class="hljs-operator">|</span> 性别   <span class="hljs-operator">|</span> 人数   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+--------+--------+</span><br><span class="hljs-operator">|</span>      <span class="hljs-number">1</span> <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span>      <span class="hljs-number">1</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>      <span class="hljs-number">2</span> <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span>      <span class="hljs-number">1</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>      <span class="hljs-number">2</span> <span class="hljs-operator">|</span>      <span class="hljs-number">1</span> <span class="hljs-operator">|</span>      <span class="hljs-number">1</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>      <span class="hljs-number">3</span> <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span>      <span class="hljs-number">2</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+--------+--------+</span><br><span class="hljs-number">4</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec<br></code></pre></div></td></tr></table></figure>
<p>3、使用 <code>hving</code> 关键字在 <code>group by</code> 的后面，添加条件。</p>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> column_name <span class="hljs-keyword">from</span> table_name <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> column_name <span class="hljs-keyword">having</span> <span class="hljs-keyword">condition</span>;<br></code></pre></div></td></tr></table></figure>
<p><code>having</code>、<code>where</code>、<code>orde by</code> 和 <code>group by</code> 句子可以在同一个 <code>select</code> 语句中一起使用，使用顺序如下: <code>Where -&gt; group by -&gt; having -&gt; order by</code></p>
<p>简单例题</p>
<p>查询人数大于2人的年级。</p>
<p><strong>规律：</strong></p>
<p><strong>的年级，年级就是group的条件。的<font color="red">什么</font>，<font color="red">什么</font>就是group的条件。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">mysql&gt; select grade as 年级, count(*) as 人数 from t2 group by grade having count(*) &gt; 1;<br>+--------+--------+<br>| 年级   | 人数   |<br>+--------+--------+<br>|      2 |      2 |<br>|      3 |      2 |<br>+--------+--------+<br>2 rows in set (0.00 sec)<br></code></pre></div></td></tr></table></figure>
<p>查询每门课程及格人数和平均分在 80 分以上的课程，的课程，课程就是group条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">select count(*) as 人数, avg(score) as 平均分, CourseID as 课程 <br>from score_table <br>where score &gt;&#x3D; 60 <br>group by courseID <br>having avg(score) &gt; 80 <br>order by courseID;<br></code></pre></div></td></tr></table></figure>
<h2 id="连接查询与子查询比较">连接查询与子查询比较</h2>
<blockquote>
<p>定义</p>
</blockquote>
<p>所谓的连接查询，就是利用各个表之间的<strong>共同列的关联性</strong>来查询数据。</p>
<p>所谓子查询（嵌套查询），就是<strong>把一个查询的结果作为另一个查询的条件。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">select grada from t1 where id&#x3D;(select id from t2 where name&#x3D;&#39;sam&#39;);<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>比较</p>
</blockquote>
<p>1、<strong>子查询（嵌套查询）就如递归函数一样</strong>，思路直接，实现简单，有时候使用起来能达到<strong>事半功倍</strong>之效，只是其<strong>执行效率</strong>较低，有时用<strong>自身连接</strong>可代替某些子查询。[实现难易和效率]</p>
<p>2、<strong>连接查询都可以用子查询替代，但不是所有子查询都能用连接查询替换</strong>，子查询比较灵活，方便，形式多样，适合用于作<strong>为查询的筛选条件</strong>，而连接查询更适合于<strong>查看多表的数据</strong>。[替换关系和用途]</p>
<p>3、子查询是本质上就是一个完整的<code>SELECT</code> 语句，它可以是一个 <code>SELECT</code>、<code>SELECT..FROM</code> 语句、<code>INSERT..INTO</code> 语句、<code>DELETE</code> 语句、或 <code>UPDATE</code> 语句或嵌套在另一子查询中。子查询的输出可以包括一个单独的值（<strong>单行子查询</strong>）、几行值（<strong>多行子查询</strong>）、或者多列数据（<strong>多列子查询</strong>）。连接查询是关系数据库中最主要的查询，主要包括内连接、外连接和交叉连接等。通过连接运算符可以实现多个表查询。连接是关系数据库模型的主要特点，也是它区别于其它类型数据库管理系统的一个标志。[细分类型的区别]</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>连接查询</th>
<th>子查询</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>实现难易</td>
<td>难</td>
<td>易</td>
</tr>
<tr class="even">
<td>效率高低</td>
<td>高</td>
<td>低</td>
</tr>
<tr class="odd">
<td>替换关系</td>
<td>都可用子查询代替</td>
<td>一部分可用连接查询代替</td>
</tr>
<tr class="even">
<td>适用情况</td>
<td>比较灵活，方便，形式多样，适合用于作<strong>为查询的筛选条件</strong>。</td>
<td>更适合于<strong>查看多表的数据</strong>。</td>
</tr>
<tr class="odd">
<td>细分类型</td>
<td>一个完整的<code>select</code>语句</td>
<td>内连接、外连接和交叉连接</td>
</tr>
</tbody>
</table>
<h2 id="drop-truncate-delete">drop &amp; truncate &amp; delete</h2>
<ul>
<li><strong>drop：</strong> <code>drop table table_name</code> 彻底删除表，包括内容和定义，并释放空间。</li>
<li><strong>truncate [trʌŋˈkeɪt]：</strong> <code>truncate table table_name</code> 清空表中的数据，保留表的数据结构 。</li>
<li><strong>delete：</strong> <code>delete from table_name where column_name = target_value）</code> 删除符合条件的行数据，不影响其他数据，也不删除表结构。</li>
</ul>
<p>其他区别： 1、执行速度一般来说： drop&gt;truncate&gt;delete。 2、delete 语句是<strong>数据库操作语言 (dml)</strong>，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger ，执行的时候将被触发。 3、truncate 、 drop 是<strong>数据库定义语言 (ddl)</strong>，操作立即生效，原数据不放到 rollback segment中，不能回滚，操作不触发 trigger 。 4、truncate 语句执行以后， id 标识列还是按顺序排列，保持连续；而 delete 语句执行后，ID 标识列不连续 。</p>
<h2 id="视图的作用以及何时能更新视图">视图的作用以及何时能更新视图</h2>
<blockquote>
<p>定义</p>
</blockquote>
<p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。 对视图的操作和对普通表的操作一样。</p>
<blockquote>
<p>视图具有如下好处</p>
</blockquote>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的连接查询；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>通过创建view，可以自定义虚拟表的数据格式和表示。</li>
</ul>
<p><em>创建</em></p>
<p>视图的sql语句如下，创建一个视图，查询人数大于1的年级：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">create view count_people as <br>select grade as 年级, count(*) as 人数 <br>from t2 <br>group by grade having count(*) &gt;  1;<br></code></pre></div></td></tr></table></figure>
<p><em>修改</em></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">alter view view_name as<br>select column_names form table_names + conditions;(新的select语句)<br></code></pre></div></td></tr></table></figure>
<p><em>删除</em></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">drop view view_name;<br></code></pre></div></td></tr></table></figure>
<p><em>使用</em></p>
<p>直接当成一个表来用就行</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">select * from view_name;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>利用视图更新数据的条件</p>
</blockquote>
<p>只由一个基表定义且只含有基表的主键或候补键，并且视图中没有用表达式或函数定义的属性的视图，才允许更新 。</p>
<p>1、只由一个基表定义，例如 <code>create view test_view as select id from A</code>，视图<code>test_view</code> 只由 <code>A</code> 表定义。</p>
<p>2、只含有基表的主键或候补键</p>
<p>3、视图中没有用表达式（<code>distinct</code>、<code>limit</code>、<code>order</code>）或函数（<code>max</code>、<code>min</code>、<code>avg</code>）定义的属性。</p>
<p>只有满足以上条件，基于 <code>view</code> 拿到的数据（一个基表的一个主键/候补键）才能用于更新数据。</p>
<blockquote>
<p>不允许更新的情况</p>
</blockquote>
<p>1、若视图是由两个以上基本表导出的，则此视图不允许更新。</p>
<p>2、若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。</p>
<p>3、若视图的字段来自集函数，则此视图<strong>不允许更新</strong>。</p>
<p>4、若视图定义中含有GROUP BY子句，则此视图<strong>不允许更新</strong>。</p>
<p>5、若视图定义中含有DISTINCT短语，则此视图<strong>不允许更新</strong>。</p>
<p>6、若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade &gt; (SELECT AVG(Grade) FROM SC); 　　导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。</p>
<p>7、一个不允许更新的视图上定义的视图也不允许更新。</p>
<h2 id="理解存储过程触发器等作用">理解存储过程、触发器等作用</h2>
<h3 id="存储过程">存储过程</h3>
<p>存储过程可以看成是<strong>一系列 SQL 操作的批处理</strong>。</p>
<p>使用存储过程的好处：</p>
<ul>
<li>代码封装，保证了一定的<strong>安全性</strong>；</li>
<li>代码复用，工程<strong>更简洁</strong>；</li>
<li>由于是预先编译，因此具有<strong>很高的性能</strong>。</li>
</ul>
<p>注意：命令行中创建存储过程需要自定义分隔符，<strong>因为命令行是以 <code>;</code> 为结束符</strong>，而存储过程中也包含了分号，因此会<strong>错误把这部分分号当成是结束符，造成语法错误。</strong></p>
<p>包含 <code>in</code>、<code>out</code> 和 <code>inout</code> 三种参数。</p>
<p>给变量赋值都需要用 <code>select into</code> 语句。</p>
<p>每次<strong>只能给一个变量赋值，不支持集合的操作。</strong></p>
<p>从 <code>table1</code> 中取出所有 <code>col1</code> 字段的和，将该和的平方放入 <code>ret</code> 表中。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">delimiter &#x2F;&#x2F;<br>create procedure testprocedure(out, ret, int)<br>    begin<br>        declare y int;<br>        select sum(col1)<br>        from table1<br>        into y;<br>        select y*y into ret;<br>    end &#x2F;&#x2F;<br>delimiter;<br></code></pre></div></td></tr></table></figure>
<p>使用该存储过程</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">call testprocedure(@ret);<br>select @ret;<br></code></pre></div></td></tr></table></figure>
<p><strong>PS：现在，在高并发、大数据的场景下，业界都不流行在数据库里面搞这些花样了。类似的逻辑，都是在后端完成，数据库只是存数据。</strong></p>
<h3 id="触发器">触发器</h3>
<blockquote>
<p>定义</p>
</blockquote>
<p>触发器是一组在某个表执行<code>DELETE</code>、<code>INSERT</code>、<code>UPDATE</code> 语句时而自动执行的 SQL 操作，保证了<strong>复杂的参照完整性</strong>和<strong>数据的一致性</strong>。</p>
<p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。<strong>BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</strong></p>
<p>触发器的主要作用是其能够实现由主键和外键所不能保证的<strong>复杂的参照完整性</strong>和<strong>数据的一致性</strong>。它能够对数据库中的相关表<strong>进行级联修改</strong>，强制比CHECK约束更复杂的数据完整性，并自定义操作消息，<strong>维护非规范化数据</strong>以及<strong>比较数据修改前后的状态</strong>。</p>
<p>创建多行触发器，当插入，更新、删除多行数据时，必须编写一个<strong>处理多行数据的触发器</strong>。执行级联更新或级联删除这样的动作。级联修改数据库中所有相关表。<strong>撤销或者回滚</strong>违反引用完整性的操作，防止非法修改数据。</p>
<blockquote>
<p>优点：</p>
</blockquote>
<p>1、通过 <strong>BEFORE</strong> 关键字实现<strong>数据验证和净化。</strong></p>
<p>2、通过 <strong>AFTER</strong> 关键字实现<strong>审计跟踪。</strong></p>
<blockquote>
<p>实现</p>
</blockquote>
<p>INSERT 触发器包含一个名为 <code>NEW</code> 的虚拟表。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE TRIGGER mytrigger AFTER INSERT ON mytable<br>FOR EACH ROW SELECT NEW.col into @result;<br><br>SELECT @result; -- 获取结果<br></code></pre></div></td></tr></table></figure>
<p>DELETE 触发器包含一个名为 <code>OLD</code> 的虚拟表，并且是只读的。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">create trigger mytrigger before delete on mytable<br>for each row select OLD.col into @result;<br><br>select @reslut;<br></code></pre></div></td></tr></table></figure>
<p>UPDATE 触发器包含一个名为 <code>NEW</code> 和一个名为 <code>OLD</code> 的虚拟表，其中 <strong>NEW 是可以被修改的</strong>，而 <strong>OLD 是只读的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">-- 创建update触发器<br>create trigger trig_update<br>on student<br>after update<br>as<br>begin<br>    declare @stuCount int;<br>    select @stuCount&#x3D;count(*) from student;<br>    update student_sum set stuCount &#x3D;@stuCount;<br>    select stu_id as 更新前学生编号,stu_name as 更新前学生姓名 from old<br>    select stu_id as 更新后学生编号,stu_name as 更新后学生姓名 from inserted<br>end<br></code></pre></div></td></tr></table></figure>
<p><strong>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</strong></p>
<h1 id="dbms">DBMS</h1>
<p>数据库系统原理（Principles of DataBase Manage System ）</p>
<h2 id="主键和外键">主键和外键</h2>
<p><strong>主键</strong>是能<strong>唯一确定</strong>当前表的一条记录的字段 <strong>外键</strong>用于当前表与另一张表的关联，能<strong>唯一确定</strong>另一张表记录的字段，用于保持数据的一致性。 A表中的一个字段，是B表的主键，该字段就可以是A表的外键。</p>
<p>学生表(学号，姓名，性别，班级) 其中每个学生的学号是唯一的，学号就是一个主键</p>
<p>课程表(课程编号,课程名,学分) 其中课程编号是唯一的,课程编号就是一个主键</p>
<p>成绩表(学号,课程号,成绩) 成绩表中单一一个属性无法唯一标识一条记录，学号和课程号的组合才可以唯一标识一条记录，所以学号和课程号的属性组是一个主键。</p>
<p>综上，学号是成绩表的外键，课程号也是成绩表的外键。</p>
<h2 id="事务管理与acid的作用以及实现原理重点">事务管理与ACID的作用以及实现原理（重点）</h2>
<h3 id="事务管理">事务管理</h3>
<ul>
<li>事务（transaction）符合 ACID 特性的一组SQL语句组成的一个<strong>程序执行单元(Unit)</strong>，该执行单元要么成功然后Commit，要么失败然后Rollback。。</li>
<li>回退（rollback）指撤销指定事务的过程。</li>
<li>提交（commit）指将未存储的事务结果写入数据库表。</li>
<li>保留点（savepoint）指事务处理中设置的临时<strong>占位符（placeholder）</strong>，你可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；<strong>也不能回退 CREATE 和 DROP 语句。</strong></p>
<p>MySQL 的事务提交<strong>默认是隐式提交</strong>，<font color='red'><strong>每执行一条语句就把这条语句当成一个事务然后进行提交。</strong></font>当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，<strong>重新恢复隐式提交。</strong></p>
<p>设置 autocommit 为 0 可以取消自动提交；<strong>autocommit 标记是针对每个连接而不是针对服务器的。</strong></p>
<p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">start transaction<br>&#x2F;&#x2F; ...<br>savepoint delete1<br>&#x2F;&#x2F; ...<br>rollback to delete1<br>&#x2F;&#x2F; ...<br>commit<br></code></pre></div></td></tr></table></figure>
<h3 id="acid">ACID</h3>
<p>ACID是数据库事务正常执行的四个基本原则，分别指原子性、一致性、独立性及持久性。</p>
<h4 id="原子性-atomicity">原子性 Atomicity</h4>
<p>Atomicity [ˌætəˈmɪsəti]</p>
<p>所谓原子性是指一个事物中所有的语句要么全执行，要么全不执行，是事务最核心的特性。事务本身就是以原子性来定义的。</p>
<p>实现主要基于 <code>undo log</code>。<code>undo log</code>名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。</p>
<p>例如</p>
<ul>
<li>当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据</li>
<li>当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作</li>
<li>当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作</li>
</ul>
<p><code>undo log</code>记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p>
<h4 id="一致性-consistency">一致性 Consistency</h4>
<p>Consistency [kənˈsɪstənsi]</p>
<p>指事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 通俗的说：我和你的钱加起来一共是2000，那么不管我和你之间如何转账，转几次账，事务结束后我们的钱相加起来应该还得是2000，这就是事务的一致性。</p>
<p><strong>事务追求的最终目标</strong>，一致性的实现既需要<strong>数据库层面的保障</strong>，也需要<strong>应用层面的保障</strong>。</p>
<p>从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，<strong>C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，</strong>是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。</p>
<p>但是，如果你在事务里故意写出违反约束的代码，一致性还是无法保证的。例如，你在转账的例子中，你的代码里故意不给B账户加钱，那一致性还是无法保证。因此，还必须从应用层角度考虑。</p>
<p>从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！</p>
<h4 id="隔离性-isolation">隔离性 Isolation</h4>
<p>Isolation [ˌaɪsəˈleɪʃn]</p>
<p>多个事务并发访问数据库时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。 通俗的说：多个用户并发访问操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>lnnoDB默认的隔离级别是RR，RR的实现主要基于<strong>锁机制、数据的隐藏列、<code>undo log</code> 和 类next-key lock 机制。</strong></p>
<p>主要利用的还是<strong>锁机制</strong>和<strong>MVCC机制</strong>。</p>
<p>锁机制：还是拿转账例子来说明，有一个账户表 <code>t_balance</code> 如下:</p>
<table>
<thead>
<tr class="header">
<th>id</th>
<th>user_id</th>
<th>balance</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>A</td>
<td>200</td>
</tr>
<tr class="even">
<td>2</td>
<td>B</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>其中id是主键，user_id为账户名，balance为余额。以转账两次为例，如下图所示</p>
<figure>
<img src="https://pic2.zhimg.com/80/v2-486b40fb28175dd1becef6e40c22d55d_hd.jpg" srcset="/img/loading.gif" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>当事务1对tableA操作时会获取tableA中事务1正在操作的行的<strong>行锁</strong>，当且仅当tableA的<strong>行锁</strong>被事务1释放时，事务2才能获得tableA的改行的<strong>行锁</strong>，进而操作tableA中这一行的数据。</p>
<p><strong>MVCC</strong>，即多版本并发控制(Multi Version Concurrency Control)，一<strong>个行记录数据有多个版本对的快照数据，这些快照数据在<code>undo log</code>中。</strong></p>
<p>如果一个事务读取的行正在做DELELE或者UPDATE操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。</p>
<p>由于MVCC机制在可重复读(Repeateable Read)和读已提交(Read Commited)的MVCC表现形式不同，就不赘述了。</p>
<p>但是有一点说明一下，在事务隔离级别为读已提交(Read Commited)时，一个事务能够读到另一个事务已经提交的数据，是不满足隔离性的。但是当事务隔离级别为可重复读(Repeateable Read)中，是满足隔离性的。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61900784">带你了解数据库中事务的ACID特性</a> / <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/65542783">MySQL的ACID原理</a> / <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/65281198">程序员，知道Mysql中ACID的原理吗？</a></p>
<h4 id="可持久性-durability">可持久性 Durability</h4>
<p>Durability [ˌdjʊərəˈbɪləti]</p>
<p>保证<strong>事务提交后</strong>不会因为宕机等原因导致数据丢失，实现主要基于 <code>redo log</code>。</p>
<p>Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上，内存就相当于一个缓冲区。如果此时突然宕机，内存中的数据就会丢失。</p>
<p><strong>这么做有什么问题？</strong></p>
<ul>
<li>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。</li>
<li>毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。</li>
</ul>
<p>采用 <code>redo log</code> 解决上面的问题，<code>redo log</code> 记录的是数据页的物理修改。当做数据修改的时候，不仅在内存中操作，还会在 <code>redo log</code>中记录这次操作。当事务提交的时候，会将 <code>redo log</code> 日志进行刷盘( <code>redo log</code> 一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将 <code>redo log</code> 中的内容恢复到数据库中，这样就保证了数据提交之后，即使遇上宕机，数据也不会丢失。（再根据<code>undo log</code>和<code>bin log</code>内容决定回滚数据还是提交数据。）</p>
<p><strong>采用redo log的好处？</strong></p>
<p>其实好处就是将<code>redo log</code>进行刷盘比对<strong>数据页刷盘</strong>效率高，具体表现如下</p>
<ul>
<li><code>redo log</code>体积小，毕竟<strong>只记录了哪一页修改了啥</strong>，因此体积小，刷盘快。</li>
<li><code>redo log</code>是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。</li>
</ul>
<h2 id="四大隔离级别以及不可重复读和幻影读的出现原因重点">四大隔离级别以及不可重复读和幻影读的出现原因（重点）</h2>
<h3 id="四大隔离级别">四大隔离级别</h3>
<h4 id="read-uncommitted读未提交">Read uncommitted（读未提交）</h4>
<p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<p>直接在磁盘上修改，就可以实现<strong>读未提交</strong>的隔离级别。</p>
<h4 id="read-committed读已提交">Read committed（读已提交）</h4>
<p>事务中的修改，只有已经提交了，对其它事务才是可见的。</p>
<p>将数据读取到内存，完成修改之后，在写回磁盘，就可以实现<strong>读已提交</strong>的隔离级别，也可以通过MVCC实现。</p>
<h4 id="repeatable-read可重复读">Repeatable read（可重复读）</h4>
<p>同一个事务中多次读取同一数据的结果是一样的。</p>
<p>基于锁机制，在事务第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现<strong>可重复读</strong>的隔离级别，也可以通过MVCC实现。</p>
<h4 id="serializable序列化串行化">Serializable（序列化/串行化）</h4>
<p>序列化/串行化隔离级别下，各个事务绝对不会相互干扰。</p>
<p>通过锁机制，保证同一时间只有一个事务在对数据进行读写，实现了多事务的串行执行，这样多个事务互不干扰，不会出现任何并发一致性问题，以此来实现<strong>序列化/串行化</strong>的隔离级别。</p>
<h3 id="三种并发一致性问题">三种并发一致性问题</h3>
<h4 id="脏读">脏读</h4>
<p><strong>所谓脏读是指一个事物读取了另一个事务还没提交的修改。</strong>举个例子，如果你正在读数据库内容，而我现在修改了数据库内容还没有提交，<strong>接着我修改后的内容没有提交的情况下被你读到了</strong>，就叫脏读。</p>
<p>通过设置<strong>读已提交</strong>的隔离级别，即可解决脏读问题。</p>
<h4 id="不可重复读">不可重复读</h4>
<p><strong>所谓不可重复读是指一个数据在被一个事务前后两次读取的中间，被另一个事务修改了。导致该事务前后两次读取结果不一样的情况。</strong>举个例子，比如你正在读数据库内容，而我update数据库后提交了，你又读了一次数据库内容，这时<strong>出现两个内容不同的结果</strong>,这叫不可重复读.</p>
<p>通过设置<strong>可重复读取</strong>的隔离级别，即可解决不可重复度问题。</p>
<h4 id="幻读">幻读</h4>
<p><strong>所谓幻读是指一个数据库在被一个事务前后两次读取的中间，另一个事务执行了insert操作。导致该事务第二次读取数据库是发现有新的记录。</strong>举个例子，比如你正在读数据库内容，而我<code>insert</code> 数据库后提交了，你又读了一次数据库内容，这时你看到内容<strong>出现了多一条数据</strong>,这叫幻读。</p>
<p>通过设置<strong>序列化/串行化</strong>的隔离级别，即可解决幻读问题。</p>
<h3 id="基于隔离级别解决并发一致性问题">基于隔离级别解决并发一致性问题</h3>
<table>
<thead>
<tr class="header">
<th></th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>读未提交</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
</tr>
<tr class="even">
<td>读已提交</td>
<td>✔</td>
<td>✘</td>
<td>✘</td>
</tr>
<tr class="odd">
<td>可重复读</td>
<td>✔</td>
<td>✔</td>
<td>✘</td>
</tr>
<tr class="even">
<td>串行化/序列化</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody>
</table>
<h2 id="封锁的类型以及粒度两段锁协议隐式和显式锁定">封锁的类型以及粒度，两段锁协议，隐式和显式锁定</h2>
<blockquote>
<p>锁级别（锁粒度）</p>
</blockquote>
<ul>
<li><p>行级锁</p></li>
<li><p>表级锁</p></li>
</ul>
<p>锁级别越小，发生锁争用的可能就越小，系统的并发程度就越高。</p>
<p>锁级别越大，加锁需要消耗资源越少，系统开销就越小。</p>
<p>选择锁级别（锁粒度）时，需要在系统开销和并发程度之间做一个权衡。</p>
<blockquote>
<p>锁类型</p>
</blockquote>
<p>1、读写锁</p>
<ul>
<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<p>2、意向锁</p>
<p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<figure>
<img src="https://i.loli.net/2020/04/07/OB9sxe4YKVFzPhJ.png" srcset="/img/loading.gif" alt="1.png" /><figcaption aria-hidden="true">1.png</figcaption>
</figure>
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
<li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li>
</ul>
<blockquote>
<p>两段锁协议</p>
</blockquote>
<p>加锁和解锁分为两个阶段进行。</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度，一起对所有数据加锁，再一起对所有数据解锁。</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">lock-x</span><span class="hljs-params">(A)</span></span>..<span class="hljs-selector-class">.lock-s</span>(B)..<span class="hljs-selector-class">.lock-s</span>(C)..<span class="hljs-selector-class">.unlock</span>(A)..<span class="hljs-selector-class">.unlock</span>(C)..<span class="hljs-selector-class">.unlock</span>(B)<br></code></pre></div></td></tr></table></figure>
<p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。加锁A，解锁A，加锁B，解锁B，......</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">lock-x</span><span class="hljs-params">(A)</span></span>..<span class="hljs-selector-class">.unlock</span>(A)..<span class="hljs-selector-class">.lock-s</span>(B)..<span class="hljs-selector-class">.unlock</span>(B)..<span class="hljs-selector-class">.lock-s</span>(C)..<span class="hljs-selector-class">.unlock</span>(C)<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>隐式和显示锁定</p>
</blockquote>
<p>MySQL 的 I<strong>nnoDB 存储引擎</strong>采用两段锁协议，</p>
<p>所谓隐式锁是指<strong>根据隔离级别在需要的时候自动加锁</strong>，并且所有的锁都是在同一时刻被释放。</p>
<p>InnoDB 也可以使用特定的语句进行显式的锁定：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT ... LOCK In SHARE MODE;<br>SELECT ... FOR UPDATE;<br></code></pre></div></td></tr></table></figure>
<h2 id="乐观锁与悲观锁重点">乐观锁与悲观锁（重点）</h2>
<h3 id="乐观锁">乐观锁</h3>
<p>所谓乐观锁就是假设数据一般情况下不会造成冲突，所以<strong>在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。</strong></p>
<p>实现机制：乐观锁不会使用数据库提供的锁机制，一般是增加<strong>version参数</strong>，记录数据版本号（版本号机制），提交事务前比对等待修改的数据的版本号和之前保存的版本号是否一致，如果一致，就说明未被修改，正常提交事务更新数据。或者基于CAS算法，CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做，<strong>整个比较并替换的操作是一个原子操作。</strong>。</p>
<h3 id="悲观锁">悲观锁</h3>
<p>悲观锁：所谓悲观锁就是认为数据并发修改的概率比较大，所以需要<strong>在修改之前先加锁</strong>。</p>
<p>之所以叫做悲观锁，是因为抱有悲观的态度去修改数据的并发控制方式，</p>
<p>实现机制：依靠数据库提供的锁机制，流程如下：</p>
<ul>
<li>在对数据修改前，尝试增加排他锁。</li>
<li>加锁失败，意味着数据正在被修改，进行<strong>等待或者抛出异常</strong>。</li>
<li>加锁成功，对数据进行修改，提交事务，锁释放。</li>
</ul>
<h3 id="乐观锁和悲观锁区别">乐观锁和悲观锁区别</h3>
<p>乐观锁不是真的加锁，效率高，但是要控制好锁的力度。悲观锁依赖数据库锁，效率低，但是更加安全。</p>
<h2 id="mvcc-原理当前读以及快照读next-key-locks-解决幻读">MVCC 原理，当前读以及快照读，Next-Key Locks 解决幻读</h2>
<h3 id="mvcc">MVCC</h3>
<p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 <strong>InnoDB 存储引擎</strong>实现隔离级别的一种具体方式。</p>
<p>用于实现 <strong>读已提交</strong> 和 <strong>可重复读</strong> 这两种隔离级别 以及事务的 <strong>独立性原则</strong>。 而 <strong>读未提交</strong> 隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。 可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<blockquote>
<p>基本思想</p>
</blockquote>
<p>加锁能解决多个事务同时执行时出现的并发一致性问题。</p>
<p>在实际场景中<strong>读操作往往多于写操作</strong>，因此又<strong>引入了读写锁</strong>来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的。</p>
<p>而 MVCC 利用了多版本的思想，<strong>写操作更新最新的版本快照，而读操作去读旧版本快照</strong>，没有互斥关系，这一点和 CopyOnWrite 类似。</p>
<blockquote>
<p>具体实现</p>
</blockquote>
<p><strong>版本号</strong></p>
<ul>
<li>系统版本号 <code>SYS_ID</code> ：全局的，针对所有事务，是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号 <code>TRX_ID</code> ：全局的，针对当前事务，当前事务开始时的系统版本号。</li>
</ul>
<p><strong>Undo 日志</strong></p>
<p>MVCC 的多版本指的是多个版本的快照，快照存储在 <code>Undo</code> 日志中，该日志通过回滚指针 <code>ROLL_PTR</code> 把一个数据行的所有快照连接起来。</p>
<p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">INSERT INTO t(id, x) VALUES(1, &quot;a&quot;);<br>UPDATE t SET x&#x3D;&quot;b&quot; WHERE id&#x3D;1;<br>UPDATE t SET x&#x3D;&quot;c&quot; WHERE id&#x3D;1;<br></code></pre></div></td></tr></table></figure>
<p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制（隐式提交），每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 <code>TRX_ID</code> 和操作之外，还记录了一个 bit 的 <code>DEL</code> 字段，用于标记是否被删除。</p>
<p><code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 操作会创建一个日志，并将事务版本号 <code>TRX_ID</code> 写入。<strong><code>DELETE</code> 可以看成是一个特殊的 <code>UPDATE</code>，还会额外将 <code>DEL</code> 字段设置为 1。</strong></p>
<p><strong>ReadView</strong></p>
<p>MVCC 维护了一个 <code>ReadView</code> 结构，主要包含了当前系统未提交的事务列表 <code>TRX_IDs &#123;TRX_ID_1, TRX_ID_2, ...&#125;</code>，还有该列表的最小值 <code>TRX_ID_MIN</code> 和 <code>TRX_ID_MAX</code>。</p>
<p>在进行 <code>SELECT</code> 操作时，根据数据行快照的 <code>TRX_ID</code> 与 <code>TRX_ID_MIN</code> 和 <code>TRX_ID_MAX</code> 之间的关系，从而判断数据行快照是否可以使用：</p>
<ul>
<li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照是在<strong>当前所有未提交事务之前</strong>进行更改的，因此可以使用。</li>
<li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在<strong>其他事务启动之后</strong>被更改的，因此不可使用。</li>
<li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：
<ul>
<li>读已提交：如果 TRX_ID 在 TRX_IDs 列表中，表示<strong>该数据行快照对应的事务还未提交</strong>，则该快照不可使用。否则表示已经提交，可以使用。</li>
<li>可重复读：不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul></li>
</ul>
<p>在数据行快照不可使用的情况下，需要沿着 <code>Undo Log</code> 的回滚指针 <code>ROLL_PTR</code> 找到下一个快照，再进行上面的判断。</p>
<h3 id="当前读以及快照读">当前读以及快照读</h3>
<blockquote>
<p>快照读</p>
</blockquote>
<p>快照读是基于MVCC和 <code>undo log</code> 来实现的，适用于简单 <code>select</code> 语句。</p>
<p>MVCC 的 SELECT 操作是快照中的数据，<strong>不需要进行加锁操作。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM table ...;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>当前读</p>
</blockquote>
<p>读取的是<strong>记录数据的最新版本</strong>，并且<strong>当前读返回的记录都会加上锁</strong>，保证其他事务不会再并发的修改这条记录。适用于 <code>insert</code>，<code>update</code>，<code>delete</code>，<code>select ... for update</code>，<code>selec ... lock in share mode</code> 语句，以及加锁了的 <code>select</code> 语句。</p>
<p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">INSERT;<br>UPDATE;<br>DELETE;<br></code></pre></div></td></tr></table></figure>
<p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT * FROM table WHERE ? lock in share mode;<br>SELECT * FROM table WHERE ? for update;<br></code></pre></div></td></tr></table></figure>
<h3 id="next-key-locks解决幻读">Next-Key Locks解决幻读</h3>
<p>next-key lock 是由<strong>Record Lock+Gap Lock</strong>组合而成，锁定一个范围，<strong>并且锁定记录本身</strong>。</p>
<p><strong>Record Locks</strong></p>
<p><font color='red'><strong>锁定一个记录上的索引，而不是记录本身。</strong></font></p>
<p>如果表没有设置索引，<strong>InnoDB</strong> 会自动在主键上创建<strong>隐藏的聚簇索引</strong>，因此 <code>Record Locks</code> 依然可以使用。</p>
<p><strong>Gap Locks</strong></p>
<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;<br></code></pre></div></td></tr></table></figure>
<p><strong>Next-Key Locks</strong></p>
<p>它是 <code>Record Locks</code> 和 <code>Gap Locks</code> 的结合，不<strong>仅锁定一个记录上的索引，也锁定索引之间的间隙。</strong>它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<figure class="highlight clojure"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-builtin-name">-</span></span>∞, <span class="hljs-number">10</span>]<br>(<span class="hljs-number">10</span>, <span class="hljs-number">11</span>]<br>(<span class="hljs-number">11</span>, <span class="hljs-number">13</span>]<br>(<span class="hljs-number">13</span>, <span class="hljs-number">20</span>]<br>(<span class="hljs-number">20</span>, +∞)<br></code></pre></div></td></tr></table></figure>
<p>这样一来就能<strong>对查询范围进行加锁，在另一个事务执行插入操作时是不被运行的，从而避免了幻读。</strong></p>
<h2 id="范式理论">范式理论</h2>
<h3 id="背景知识">背景知识</h3>
<p><strong>实体</strong> 就数据库而言，实体往往指某类事物的集合。<strong>把每一类数据对象的个体称为实体。</strong></p>
<p><strong>函数依赖</strong> 记 A-&gt;B 表示 <strong>A 属性集决定B属性集</strong>，也可以说 <strong>B 函数依赖于 A</strong>。 对于 A-&gt;B，如果能找到A的真子集A'，使得A'-&gt;B，那么A-&gt;B 是<strong>B部分函数依赖于A</strong>，否则就是<strong>B完全函数依赖A</strong>。 对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个<strong>传递函数依赖</strong>。</p>
<p><strong>键码</strong> 实体所具有的特性称作属性，把可以用来<strong>特定标识某个实体的单个属性或者最小属性集合称为键码</strong>。</p>
<p><strong>异常</strong> 以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，<strong>确定学生和课程之后，就能确定其它信息。</strong></p>
<table>
<thead>
<tr class="header">
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr class="even">
<td>2</td>
<td><font color='red'><strong>学生-2</strong></font></td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr class="odd">
<td>2</td>
<td><font color='red'><strong>学生-2</strong></font></td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr class="even">
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody>
</table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，<strong>如果这个学生还没选课，那么就无法插入。</strong></li>
</ul>
<h3 id="范式">范式</h3>
<p><strong><font color='red'>范式理论是为了解决以上提到四种异常。</font></strong></p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<h4 id="第一范式">第一范式</h4>
<p><strong>属性不可分（列不可分）</strong>：指数据库的每一列都是不可分割的基本数据项，<strong>同一列不能有多个值</strong>，即<strong>实体中的某个属性不能有多个相同的值或者不能有重复的属性</strong>。</p>
<p>指导原则 （1）记录的每个属性只能包含一个值。 （2）表中的每个记录必须包含相同数量的值。 （3）表中不能出现完全相同的两个记录。</p>
<p>第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p>
<h4 id="第二范式">第二范式</h4>
<p><strong>在满足第一范式的基础上，每个非主属性必须完全函数依赖于主属性(主键/键码)，不能部分函数依赖于主属性</strong>。</p>
<p>如果一个数据表已经满足第一范式，而且该数据表中的<strong>任何一个非主键字段的</strong>数值都完全函数依赖于该数据表的主键字段，那么该数据表满足第二范式。</p>
<p><strong>可以通过将不满足第二范式的表分解成多个表，使得其满足第二范式。</strong></p>
<blockquote>
<p>举个栗子</p>
</blockquote>
<p><strong>分解前</strong></p>
<table>
<thead>
<tr class="header">
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr class="even">
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr class="odd">
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr class="even">
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody>
</table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade <strong>完全函数依赖</strong>于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。 Sname, Sdept 和 Mname 都<strong>部分依赖</strong>于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><strong>分解后</strong></p>
<p>关系-1/表-1（主键Sno）</p>
<table>
<thead>
<tr class="header">
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
</tr>
<tr class="even">
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
</tr>
<tr class="odd">
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept （ Sname, Sdept 直接完全函数依赖于主键Sno）</li>
<li>Sdept -&gt; Mname（Mname 间接完全函数依赖于主键Sno）</li>
</ul>
<p>关系-2/表-1 （主键Sno, Cname ）</p>
<table>
<thead>
<tr class="header">
<th>Sno</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr class="even">
<td>2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr class="odd">
<td>2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr class="even">
<td>3</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt; Grade （Grade 完全函数依赖于主键Sno, Cname ）</li>
</ul>
<p>这样虽然之前的表不满足第二范式，但是<strong>分解之后的两个表就满足第二范式了。</strong></p>
<h4 id="第三范式">第三范式</h4>
<p>在满足第二范式的基础上，非主属性<strong>不传递函数依赖于</strong>主属性(主键/键码)，那么该数据表满足第三范式。 换而言之，如果一个数据表已经满足第二范式，而且<strong>该数据表中的任何两个非主键字段的数据值之间不存在函数依赖关系</strong>，那么该数据表满足第三范式。 简而言之，第三范式（3NF）要求一个数据库表中不包含己在其它表中<strong>已包含的非主关键字信息</strong>。 上面三行是同一个意思，你细品。</p>
<p><strong>可以通过将不满足第二范式的表分解成多个表，使得其满足第二范式。</strong></p>
<blockquote>
<p>举个栗子</p>
</blockquote>
<p>下面的 关系-1/表-1 中存在以下传递函数依赖：Sno -&gt; Sdept -&gt; Mname，Mname是其他表中<strong>已包含的非主关键字信息</strong>。</p>
<p>关系-1/表-1（主键Sno）</p>
<table>
<thead>
<tr class="header">
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
</tr>
<tr class="even">
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
</tr>
<tr class="odd">
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
</tr>
</tbody>
</table>
<p>可以进行以下分解：</p>
<p>关系-11/表-11（主键Sno）</p>
<table>
<thead>
<tr class="header">
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
</tr>
<tr class="even">
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
</tr>
<tr class="odd">
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
</tr>
</tbody>
</table>
<p>关系-12/表-12（主键Sdept）</p>
<table>
<thead>
<tr class="header">
<th>Sdept</th>
<th>Mname</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>学院-1</td>
<td>院长-1</td>
</tr>
<tr class="even">
<td>学院-2</td>
<td>院长-2</td>
</tr>
</tbody>
</table>
<p>这样，所有表都满足第三范式了，就不会出现任何异常了。</p>
<h2 id="sql-与-nosql-的比较">SQL 与 NoSQL 的比较</h2>
<p><strong>SQL（Structured Query Language）数据库</strong></p>
<p>指关系型数据库，主要代表：SQL Server，Oracle，MySQL，PostgreSQL。</p>
<p><strong>NoSQL（Not Only sQL）数据库</strong></p>
<p>泛指非关系型数据库，主要代表：MongoDB，Redis，CouchDB。</p>
<blockquote>
<p>SQL 与 NoSQL 的比较表</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th></th>
<th>SQL</th>
<th>NoSql</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>存储基础</td>
<td>基于表的存储</td>
<td>基于类<code>Json</code> 对象的存储</td>
</tr>
<tr class="even">
<td>存储关系</td>
<td>记录 <span class="math inline">\(\in\)</span> 表 <span class="math inline">\(\in\)</span> 数据库</td>
<td>条目 <span class="math inline">\(\in\)</span> 文档 <span class="math inline">\(\in\)</span> 集合</td>
</tr>
<tr class="odd">
<td>预定义要求</td>
<td>表结构需要预定义</td>
<td>无需预定义</td>
</tr>
<tr class="even">
<td>支持连接查询</td>
<td>支持，允许使用一条SQL语句从多张表中取出相关的数据。</td>
<td>不支持</td>
</tr>
<tr class="odd">
<td>完整性要求</td>
<td>需要满足数据完整性约束规则，使用事务来保证数据的一致性。</td>
<td>不需要，允许数据不用通过验证就可以存储到任意的位置。</td>
</tr>
<tr class="even">
<td>其他</td>
<td>用户多，工具多。</td>
<td>性能强，可扩展性强。</td>
</tr>
<tr class="odd">
<td>应用场景</td>
<td>逻辑关系需要事先定义，数据一致性是必要条件。</td>
<td>不相关，不确定和逐步发展的数据需求 速度和可扩展性至关重要的</td>
</tr>
</tbody>
</table>
<blockquote>
<p>SQL 数据库</p>
</blockquote>
<ul>
<li>使用表存储相关的数据。</li>
<li>在使用表之前需要先定义表的模式，鼓励使用规范化来减少数据的冗余。</li>
<li>支持使用 <code>join</code> 操作（连接查询），使用一条SQL语句从多张表中取出相关的数据。</li>
<li>需要满足数据完整性约束规则，使用事务来保证数据的一致性。</li>
<li>能够大规模的使用。</li>
<li>使用强大的SQL 语言进行查询操作，提供大量的支持，专业技能和辅助工具。</li>
</ul>
<blockquote>
<p>NoSQL 数据库</p>
</blockquote>
<ul>
<li>使用类 <code>JSON</code> 格式的文档来存储键值对信息。</li>
<li>存储数据不需要特定的模式。</li>
<li>使用非规范化的标准存储信息，以保证一个文档中包含一个条目的所有信息。</li>
<li>不需要使用 <code>join</code> 操作</li>
<li>允许数据不用通过验证就可以存储到任意的位置</li>
<li>保证更新的单个文档，而不是多个文档</li>
<li>提供卓越的性能和可扩展性</li>
<li>使用 <code>JSON</code> 数据对象进行查询</li>
<li>是一种新型的技术</li>
</ul>
<blockquote>
<p>适合使用SQL开发的项目</p>
</blockquote>
<ul>
<li>可以预先定义逻辑相关的离散数据的需求</li>
<li>数据一致性是必要的</li>
<li>具有良好的开发者经验和技术支持的标准的成熟技术</li>
</ul>
<blockquote>
<p>适合使用NoSQL开发的项目</p>
</blockquote>
<ul>
<li>不相关，不确定和逐步发展的数据需求</li>
<li>更简单或者更宽松的能够快速开始编程的项目</li>
<li>速度和可扩展性至关重要的</li>
</ul>
<h1 id="mysql">Mysql</h1>
<h2 id="常用命令">常用命令</h2>
<h3 id="login"><strong>login</strong></h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mysql -h 0.0.0.0 -u root -p<br>Enter password: <br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 1719<br>Server version: 5.7.22-0ubuntu0.16.04.1 (Ubuntu)<br><br>Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation and/or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type <span class="hljs-string">&#x27;help;&#x27;</span> or <span class="hljs-string">&#x27;\h&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>. Type <span class="hljs-string">&#x27;\c&#x27;</span> to clear the current input statement.<br><br>mysql&gt;<br></code></pre></div></td></tr></table></figure>
<h3 id="logout"><strong>logout</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">mysql&gt; exit<br>Bye<br></code></pre></div></td></tr></table></figure>
<h3 id="show-databases"><strong>show databases</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| brl_checkIn        |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+--------------------+<br></code></pre></div></td></tr></table></figure>
<h3 id="select-database"><strong>select database</strong></h3>
<figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">mysql&gt; use brl_checkIn<br>Reading <span class="hljs-keyword">table</span> information <span class="hljs-keyword">for</span> completion <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">column</span> names<br>You can turn <span class="hljs-keyword">off</span> this feature <span class="hljs-keyword">to</span> <span class="hljs-keyword">get</span> a quicker startup <span class="hljs-keyword">with</span> -A<br><span class="hljs-keyword">Database</span> changed<br></code></pre></div></td></tr></table></figure>
<h3 id="show-tables"><strong>show tables</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">mysql&gt; show tables;<br>+-------------------+<br>| Tables_in_test_db |<br>+-------------------+<br>| t1                |<br>| t2                |<br>+-------------------+<br>2 rows in set (0.00 sec)<br></code></pre></div></td></tr></table></figure>
<h3 id="show-table-detail"><strong>show table detail</strong></h3>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">desc</span> app_group;<br><span class="hljs-operator">+</span><span class="hljs-comment">----------+---------------+------+-----+---------+----------------+</span><br><span class="hljs-operator">|</span> Field    <span class="hljs-operator">|</span> Type          <span class="hljs-operator">|</span> <span class="hljs-keyword">Null</span> <span class="hljs-operator">|</span> Key <span class="hljs-operator">|</span> <span class="hljs-keyword">Default</span> <span class="hljs-operator">|</span> Extra          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+---------------+------+-----+---------+----------------+</span><br><span class="hljs-operator">|</span> id       <span class="hljs-operator">|</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>)       <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span>   <span class="hljs-operator">|</span> PRI <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> auto_increment <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> name     <span class="hljs-operator">|</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">500</span>)  <span class="hljs-operator">|</span> YES  <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span>                <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> remarks  <span class="hljs-operator">|</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">1000</span>) <span class="hljs-operator">|</span> YES  <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span>                <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> admin_id <span class="hljs-operator">|</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>)       <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span>   <span class="hljs-operator">|</span> MUL <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span>                <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+---------------+------+-----+---------+----------------+</span><br><span class="hljs-number">4</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></div></td></tr></table></figure>
<h3 id="create-database"><strong>create database</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">mysql&gt; create database test_db;<br>Query OK, 1 row affected (0.00 sec)<br><br>create databas [IF NOT EXISTS] &lt;数据库名&gt;<br>[[DEFAULT] CHARACTER SET &lt;字符集名&gt;] <br>[[DEFAULT] COLLATE &lt;校对规则名&gt;];<br></code></pre></div></td></tr></table></figure>
<h3 id="create-table"><strong>create table</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">mysql&gt; use test_db;<br>Database changed<br>mysql&gt; create table t1(<br>    -&gt; id int not null primary key,<br>    -&gt; name char(50) not null<br>    -&gt; );<br>Query OK, 0 rows affected (0.17 sec)<br><br>mysql&gt; desc t1;<br>+-------+----------+------+-----+---------+-------+<br>| Field | Type     | Null | Key | Default | Extra |<br>+-------+----------+------+-----+---------+-------+<br>| id    | int(11)  | NO   | PRI | NULL    |       |<br>| name  | char(50) | NO   |     | NULL    |       |<br>+-------+----------+------+-----+---------+-------+<br>2 rows in set (0.00 sec)<br></code></pre></div></td></tr></table></figure>
<h3 id="delete-table"><strong>delete table</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">&#x2F;* 清空表 *&#x2F;<br>mysql&gt; truncate table t1;<br>Query OK, 0 rows affected (0.03 sec)<br><br>mysql&gt; select * from t1;<br>Empty set (0.00 sec)<br><br>&#x2F;* 删除表 *&#x2F;<br>mysql&gt; drop table t1;<br>Query OK, 0 rows affected (0.03 sec)<br><br>mysql&gt; show tables;<br>Empty set (0.00 sec)<br></code></pre></div></td></tr></table></figure>
<h3 id="change-table"><strong>change table</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">&#x2F;* 范式 *&#x2F;<br>alter table table_name operation_name[add&#x2F;drop&#x2F;change]<br></code></pre></div></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">&#x2F;* add new field 注意：这里添加内容外面有括号，column和data type之间是空格，不是逗号。*&#x2F;<br>mysql&gt; alter table t1 add(score int not null);<br>Query OK, 0 rows affected (0.08 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br><br>mysql&gt; desc t1;<br>+-------+----------+------+-----+---------+-------+<br>| Field | Type     | Null | Key | Default | Extra |<br>+-------+----------+------+-----+---------+-------+<br>| id    | int(11)  | NO   | PRI | NULL    |       |<br>| name  | char(50) | NO   |     | NULL    |       |<br>| score | int(11)  | NO   |     | NULL    |       |<br>+-------+----------+------+-----+---------+-------+<br>3 rows in set (0.00 sec)<br><br>&#x2F;* delete field *&#x2F;<br>mysql&gt; alter table t1 drop column score;<br>Query OK, 0 rows affected (0.08 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br><br>mysql&gt; desc t1;<br>+-------+----------+------+-----+---------+-------+<br>| Field | Type     | Null | Key | Default | Extra |<br>+-------+----------+------+-----+---------+-------+<br>| id    | int(11)  | NO   | PRI | NULL    |       |<br>| name  | char(50) | NO   |     | NULL    |       |<br>+-------+----------+------+-----+---------+-------+<br>2 rows in set (0.00 sec)<br><br>&#x2F;* change field 注意：这里添加内容外面没有括号*&#x2F;<br>mysql&gt; alter table t1 change score grand char(20) not null;<br>Query OK, 0 rows affected (0.10 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br><br>mysql&gt; desc t1;<br>+-------+----------+------+-----+---------+-------+<br>| Field | Type     | Null | Key | Default | Extra |<br>+-------+----------+------+-----+---------+-------+<br>| id    | int(11)  | NO   | PRI | NULL    |       |<br>| name  | char(50) | NO   |     | NULL    |       |<br>| grand | char(20) | NO   |     | NULL    |       |<br>+-------+----------+------+-----+---------+-------+<br>3 rows in set (0.00 sec)<br></code></pre></div></td></tr></table></figure>
<h3 id="add-data-into-table"><strong>add data into table</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">mysql&gt; insert into t1 value(001, &#39;tom&#39;, &#39;1&#39;);<br>Query OK, 1 row affected (0.03 sec)<br><br>mysql&gt; select * from t1;<br>+----+------+-------+<br>| id | name | grand |<br>+----+------+-------+<br>|  1 | tom  | 1     |<br>+----+------+-------+<br>1 row in set (0.00 sec)<br><br>&#x2F;* insert table with only a few values *&#x2F;<br>mysql&gt; select * from t1;<br>+----+------+-------+<br>| id | name | grand |<br>+----+------+-------+<br>|  1 | tom  | 1     |<br>|  2 | NULL | NULL  |<br>+----+------+-------+<br>2 rows in set (0.00 sec)<br></code></pre></div></td></tr></table></figure>
<p><strong>delete data from table</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">mysql&gt; delete from t1 where id&#x3D;2;<br>Query OK, 1 row affected (0.06 sec)<br><br>mysql&gt; select * from t1;<br>+----+------+-------+<br>| id | name | grand |<br>+----+------+-------+<br>|  1 | tom  | 1     |<br>+----+------+-------+<br>1 row in set (0.00 sec)<br></code></pre></div></td></tr></table></figure>
<h3 id="update-data-from-table"><strong>update data from table</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">mysql&gt; update t1 set grand&#x3D;&#39;2&#39; where name&#x3D;&#39;tom&#39;;<br>Query OK, 1 row affected (0.01 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br><br>mysql&gt; select * from t1;<br>+----+------+-------+<br>| id | name | grand |<br>+----+------+-------+<br>|  1 | tom  | 2     |<br>+----+------+-------+<br><br>&#x2F;* 多条件更新 *&#x2F;<br>mysql&gt; select * from t2;<br>+----+-------+------+-------+<br>| id | name  | ssex | grade |<br>+----+-------+------+-------+<br>|  1 | sam   |    0 |     1 |<br>|  2 | kitty |    1 |  NULL |<br>|  3 | Laho  |    0 |  NULL |<br>|  4 | Laho  |    0 |  NULL |<br>+----+-------+------+-------+<br>4 rows in set (0.00 sec)<br>update t2 set grade&#x3D;3 where id&#x3D;3 or id&#x3D;4;<br><br>mysql&gt; select * from t2;<br>+----+-------+------+-------+<br>| id | name  | ssex | grade |<br>+----+-------+------+-------+<br>|  1 | sam   |    0 |     1 |<br>|  2 | kitty |    1 |     2 |<br>|  3 | Laho  |    0 |     3 |<br>|  4 | Laho  |    0 |     3 |<br>+----+-------+------+-------+<br>4 rows in set (0.00 sec)<br><br></code></pre></div></td></tr></table></figure>
<h3 id="simple-query-data-from-table"><strong>simple query data from table</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">&#x2F;* 单表全字段查询 *&#x2F;<br>select * form t1;<br><br>&#x2F;* 单表个别字段查询 *&#x2F;<br>select id from t1;<br><br>&#x2F;* 多表查询 *&#x2F;<br>mysql&gt; select * from t1;<br>+----+------+-------+<br>| id | name | grand |<br>+----+------+-------+<br>|  1 | tom  | 2     |<br>+----+------+-------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; select * from t2;<br>+----+-------+<br>| id | name  |<br>+----+-------+<br>|  1 | sam   |<br>|  2 | kitty |<br>+----+-------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; select t1.name,t2.name from t1,t2;<br>+------+-------+<br>| name | name  |<br>+------+-------+<br>| tom  | sam   |<br>| tom  | kitty |<br>+------+-------+<br><br>&#x2F;* 单条件查询 *&#x2F;<br>mysql&gt; select * from t1 where name&#x3D;&#39;tom&#39;;<br>+----+------+-------+<br>| id | name | grand |<br>+----+------+-------+<br>|  1 | tom  | 2     |<br>+----+------+-------+<br>1 row in set (0.00 sec)<br><br>&#x2F;* 多表条件查询 *&#x2F;<br>mysql&gt; select t1.name, t2.name from t1, t2 where t1.id&#x3D;t2.id;<br>+------+------+<br>| name | name |<br>+------+------+<br>| tom  | sam  |<br>+------+------+<br>1 row in set (0.00 sec)<br><br>&#x2F;* 子查询&#x2F;嵌套查询 t1中id和t2中sam的id一样的那个同学的年级是？ *&#x2F;<br>mysql&gt; select grand from t1 where id&#x3D;(select id from t2 where name&#x3D;&#39;sam&#39;);<br>+-------+<br>| grand |<br>+-------+<br>| 2     |<br>+-------+<br>1 row in set (0.00 sec)<br><br>&#x2F;* 交查询 t1和t2都有的id? *&#x2F;<br>mysql&gt; select id from t1 where id in (select id from t2);<br>+----+<br>| id |<br>+----+<br>|  1 |<br>+----+<br>1 row in set (0.00 sec)<br><br>&#x2F;* 并查询 t1和t2所有的id都有哪些?*&#x2F;<br>mysql&gt; (select id from t1) union (select id from t2);<br>+----+<br>| id |<br>+----+<br>|  1 |<br>|  2 |<br>|  3 |<br>+----+<br>3 rows in set (0.00 sec)<br><br></code></pre></div></td></tr></table></figure>
<p><strong>union 和 union all的区别</strong></p>
<p>union 操作符用于<strong>合并</strong>两个或多个 SELECT 语句的结果集。 请注意，union 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 union：对两个结果集进行并集操作，不包括重复行，也就是<strong>会去重</strong>，同时<strong>进行默认规则的排序</strong>； union all：对两个结果集进行并集操作，包括重复行，<strong>不会去重</strong>，不进行排序；</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">mysql&gt; select * from Table1;<br>+----+------+<br>| id | name |<br>+----+------+<br>|  1 | tom  |<br>|  2 | jack |<br>|  3 | lili |<br>+----+------+<br>3 rows in set (0.00 sec)<br><br>mysql&gt; select * from Table2;<br>+----+-------+<br>| id | name  |<br>+----+-------+<br>|  1 | tom   |<br>|  2 | Loha  |<br>|  3 | Kitty |<br>|  4 | Tite  |<br>+----+-------+<br>4 rows in set (0.00 sec)<br><br>&#x2F;* 可以发现Table1和Table2都有 id&#x3D;1 name&#x3D;tom 这条记录 *&#x2F;<br>mysql&gt; select * from Table1  <br>    -&gt; union   <br>    -&gt; select * from Table2;<br>+----+-------+<br>| id | name  |<br>+----+-------+<br>|  1 | tom   |<br>|  2 | jack  |<br>|  3 | lili  |<br>|  2 | Loha  |<br>|  3 | Kitty |<br>|  4 | Tite  |<br>+----+-------+<br>6 rows in set (0.00 sec)<br>&#x2F;* 由于 tom 这条记录在两个表中都出现过，所以这里使用union求并集，去重，就会出现了一次。 *&#x2F;<br><br>mysql&gt; select * from Table1  <br>    -&gt; union all  <br>    -&gt; select * from Table2; <br>+----+-------+<br>| id | name  |<br>+----+-------+<br>|  1 | tom   |<br>|  2 | jack  |<br>|  3 | lili  |<br>|  1 | tom   |<br>|  2 | Loha  |<br>|  3 | Kitty |<br>|  4 | Tite  |<br>+----+-------+<br>7 rows in set (0.00 sec)<br>&#x2F;* 由于 tom 这条记录在两个表中都出现过，所以这里使用union all求并集，不去重，就会出现了两次。 *&#x2F;<br></code></pre></div></td></tr></table></figure>
<h3 id="common-modifier"><strong>Common modifier</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">&#x2F;* 去重 *&#x2F;<br>mysql&gt; select * from t2;<br>+----+-------+<br>| id | name  |<br>+----+-------+<br>|  1 | sam   |<br>|  2 | kitty |<br>|  3 | Laho  |<br>|  4 | Laho  |<br>+----+-------+<br>4 rows in set (0.00 sec)<br><br>mysql&gt; select distinct name from t2;<br>+-------+<br>| name  |<br>+-------+<br>| sam   |<br>| kitty |<br>| Laho  |<br>+-------+<br>3 rows in set (0.00 sec)<br><br>&#x2F;* 限制查询结果数量 *&#x2F;<br>mysql&gt; select * from t2 limit 2;<br>+----+-------+<br>| id | name  |<br>+----+-------+<br>|  1 | sam   |<br>|  2 | kitty |<br>+----+-------+<br>2 rows in set (0.01 sec)<br><br>&#x2F;* 排序 默认是升序 *&#x2F;<br>mysql&gt; select * from t2 order by id;<br>+----+-------+<br>| id | name  |<br>+----+-------+<br>|  1 | sam   |<br>|  2 | kitty |<br>|  3 | Laho  |<br>|  4 | Laho  |<br>+----+-------+<br>4 rows in set (0.00 sec)<br><br>&#x2F;* 降序 *&#x2F;<br>mysql&gt; select * from t2 order by id desc;<br>+----+-------+<br>| id | name  |<br>+----+-------+<br>|  4 | Laho  |<br>|  3 | Laho  |<br>|  2 | kitty |<br>|  1 | sam   |<br>+----+-------+<br>4 rows in set (0.00 sec)<br></code></pre></div></td></tr></table></figure>
<h3 id="common-functions"><strong>Common functions</strong></h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">select operation[max&#x2F;min&#x2F;count&#x2F;avg&#x2F;sum](column_name) from table_name;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">&#x2F;* 求最大值 *&#x2F;<br>&#x2F;* 注： max(colunm) 返回字母序最大的，返回数值最大的 *&#x2F;<br>mysql&gt; select max(id) from t2;<br>+---------+<br>| max(id) |<br>+---------+<br>|       3 |<br>+---------+<br>1 row in set (0.00 sec)<br><br>&#x2F;* 求最小值 *&#x2F;<br>&#x2F;* 注： max(colunm) 返回字母序最小的，返回数值最小的 *&#x2F;<br>mysql&gt; select min(id) from t2;<br>+---------+<br>| min(id) |<br>+---------+<br>|       1 |<br>+---------+<br>1 row in set (0.00 sec)<br><br>&#x2F;* 计数 *&#x2F;<br>mysql&gt; select count(name) from t2;<br>+-------------+<br>| count(name) |<br>+-------------+<br>|           3 |<br>+-------------+<br>1 row in set (0.00 sec)<br><br>&#x2F;* 求均值 *&#x2F;<br>mysql&gt; select avg(id) from t2;<br>+---------+<br>| avg(id) |<br>+---------+<br>|  2.0000 |<br>+---------+<br>1 row in set (0.00 sec)<br><br>&#x2F;* 求和 *&#x2F;<br>mysql&gt; select sum(id) from t2;<br>+---------+<br>| sum(id) |<br>+---------+<br>|       6 |<br>+---------+<br>1 row in set (0.00 sec)<br></code></pre></div></td></tr></table></figure>
<h2 id="mysql常用命令总结">Mysql常用命令总结</h2>
<ul>
<li><p>求并集用 <code>union</code> 或者 <code>union all</code> 关键字；</p></li>
<li><p>求交集（就是连接查询）用 <code>=</code>、<code>inner join ... on</code> 实现不同表之间查询结果的交集；</p></li>
<li><p>求差集可以用 <code>left join on</code>、<code>right join on</code> 来实现。 例如：已知 Table1 和 Table2 如下</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">mysql&gt; select * <span class="hljs-keyword">from</span> Table1;<br>+----+------+<br>| <span class="hljs-built_in">id</span> | name |<br>+----+------+<br>|  <span class="hljs-number">1</span> | tom  |<br>|  <span class="hljs-number">2</span> | jack |<br>|  <span class="hljs-number">3</span> | lili |<br>+----+------+<br><span class="hljs-number">3</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql&gt; select * <span class="hljs-keyword">from</span> Table2;<br>+----+-------+<br>| <span class="hljs-built_in">id</span> | name  |<br>+----+-------+<br>|  <span class="hljs-number">1</span> | tom   |<br>|  <span class="hljs-number">2</span> | Loha  |<br>|  <span class="hljs-number">3</span> | Kitty |<br>|  <span class="hljs-number">4</span> | Tite  |<br>+----+-------+<br><span class="hljs-number">4</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></div></td></tr></table></figure>
<p>求 Table1 相对于 Table2 的差集，也就是 Table1(主表) 中相对于 Table2 中没有的部分，用 <code>Table1 left join Table2</code> 来实现。可以发现 jack 和 lili 这两条记录就是 Table1 相对于 Table2 的差集，后面的Null意味着这两条记录，只在Table1中出现，没有在Table2中出现。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">mysql&gt; select * <span class="hljs-keyword">from</span> Table1 left join Table2 on Table1.name = Table2.name;<br>+----+------+------+------+<br>| <span class="hljs-built_in">id</span> | name | <span class="hljs-built_in">id</span>   | name |<br>+----+------+------+------+<br>|  <span class="hljs-number">1</span> | tom  |    <span class="hljs-number">1</span> | tom  |<br>|  <span class="hljs-number">2</span> | jack | NULL | NULL |<br>|  <span class="hljs-number">3</span> | lili | NULL | NULL |<br>+----+------+------+------+<br><span class="hljs-number">3</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></div></td></tr></table></figure>
<p>同理，求 Table2 相对于 Table1 的差集，也就是 Table2(主表) 中相对于 Table1 中没有的部分，用 <code>Table1 right join Table2</code> 来实现。可以发现 Loha、Kitty 和 Tite 这三条记录就是 Table2 相对于 Table1 的差集，前面的Null意味着这三条记录，只在Table2中出现，没有在Table1中出现。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">mysql&gt; select * from Table1 right join Table2 on Table1.name &#x3D; Table2.name;<br>+------+------+----+-------+<br>| id   | name | id | name  |<br>+------+------+----+-------+<br>|    1 | tom  |  1 | tom   |<br>| NULL | NULL |  2 | Loha  |<br>| NULL | NULL |  3 | Kitty |<br>| NULL | NULL |  4 | Tite  |<br>+------+------+----+-------+<br>4 rows in set (0.00 sec)<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h2 id="mysql-索引以及优化">MySQL 索引以及优化</h2>
<h3 id="索引的定义">索引的定义</h3>
<p><strong>索引是对数据库表中一列或多列的值进行排序的一种结构</strong>，使用索引可快速访问数据库表中的特定信息。</p>
<p>索引是在表的列上创建，所以，要记住的关键点是<strong>索引包含一个表中列的值</strong>，并且这些值存储在一个数据结构中。请记住记住这一点：索引是一种数据结构 。</p>
<p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<p>索引的执行语句</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">&#x2F;* 创建索引 *&#x2F;<br>create index t1Index on t1 (name);<br><br>&#x2F;* 创建唯一索引 *&#x2F;<br>create unique t1Index on t1 (id);<br><br>&#x2F;* 移除索引 *&#x2F;<br>drop index t1Index on t1;<br></code></pre></div></td></tr></table></figure>
<h3 id="mysql索引类型">Mysql索引类型</h3>
<h4 id="b-tree索引">B+ Tree索引</h4>
<p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p>
<p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。<strong>主索引的叶子节点 data 域记录着完整的数据记录（叶子节点，1、2，3、4，5、6）</strong>，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/68aaad622e8561419c29c6a0a37ab7bb53c10d14/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34353031366539382d363837392d343730392d383536392d3236326232643664363062392e706e67"><img src="https://camo.githubusercontent.com/68aaad622e8561419c29c6a0a37ab7bb53c10d14/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34353031366539382d363837392d343730392d383536392d3236326232643664363062392e706e67" srcset="/img/loading.gif" alt="img" /></a></p>
<p><strong>辅助索引的叶子节点的 data 域记录着主键的值（非叶子节点c、e）</strong>，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/dd47755ce0994df42de07ee39f185aa53c3af3bc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37633334396239312d303530622d346437322d613766382d6563383633323033303765612e706e67"><img src="https://camo.githubusercontent.com/dd47755ce0994df42de07ee39f185aa53c3af3bc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37633334396239312d303530622d346437322d613766382d6563383633323033303765612e706e67" srcset="/img/loading.gif" alt="img" /></a></p>
<h4 id="哈希索引">哈希索引</h4>
<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h4 id="全文索引">全文索引</h4>
<p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>
<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h4 id="空间数据索引">空间数据索引</h4>
<p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h3 id="索引优化">索引优化</h3>
<h4 id="独立的列">独立的列</h4>
<p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> actor_id <span class="hljs-keyword">FROM</span> sakila.actor <span class="hljs-keyword">WHERE</span> actor_id + <span class="hljs-number">1</span> = <span class="hljs-number">5</span>;<br></code></pre></div></td></tr></table></figure>
<h4 id="多列索引">多列索引</h4>
<p><strong>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。</strong> 例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> film_id, actor_ id <span class="hljs-keyword">FROM</span> sakila.film_actor<br><span class="hljs-keyword">WHERE</span> actor_id = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> film_id = <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>
<h4 id="索引列的顺序">索引列的顺序</h4>
<p><strong>让选择性最强的索引列放在前面。</strong></p>
<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span> COUNT(<span class="hljs-keyword">DISTINCT</span> staff_id)/COUNT<span class="hljs-comment">(*) AS staff_id_selectivity,</span><br><span class="hljs-comment">COUNT(DISTINCT customer_id)/COUNT(*)</span> <span class="hljs-keyword">AS</span> customer_id_selectivity,<br>COUNT<span class="hljs-comment">(*)</span><br><span class="hljs-comment">FROM payment;</span><br><span class="hljs-comment">   staff_id_selectivity: 0.0001</span><br><span class="hljs-comment">customer_id_selectivity: 0.0373</span><br><span class="hljs-comment">               COUNT(*)</span>: <span class="hljs-number">16049</span><br></code></pre></div></td></tr></table></figure>
<h4 id="前缀索引">前缀索引</h4>
<p>对于 BLOB、TEXT 和 VARCHAR 类型的列，由于数据比较长，所以必须使用前缀索引，<strong>只索引开始的部分字符。</strong></p>
<p>前缀长度的选取需要根据索引选择性来确定。</p>
<h4 id="覆盖索引">覆盖索引</h4>
<p>所谓覆盖索引是指<strong>索引包含所有需要查询的字段的值</strong>。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引，直接去访问辅助索引就能完成查找。</li>
</ul>
<h3 id="索引的优点">索引的优点</h3>
<ul>
<li><strong>大大减少了</strong>服务器需要扫描的数据行数。</li>
<li>帮助服务器<strong>避免进行排序和分组</strong>，以及避免创建临时表（B+Tree 索引是有序的，可以用于 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。临时表主要是在<strong>排序和分组</strong>过程中创建，不需要排序和分组，也就不需要创建临时表）。</li>
<li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li>
</ul>
<h2 id="索引的使用条件">索引的使用条件</h2>
<ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>
<li>对于中到大型的表，索引就非常有效；</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用<strong>分区技术。</strong></li>
</ul>
<h2 id="哪些字段适合建立索引">哪些字段适合建立索引</h2>
<p><em>参考链接</em></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deepalley/p/10784756.html">哪些字段适合建立索引</a></p>
<p>经常需要进行更新操作的属性</p>
<p>1、表的主键、外键必须有索引； 2、数据量达到300+以上的表应该有索引； 3、经常与其他表进行连接的表，在连接字段上应该建立索引； 4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引； 5、索引应该建在选择性高的字段上； 6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； 7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替： A、正确选择复合索引中的主列字段，一般是选择性较好的字段； B、复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引； D、如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； E、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引； 8、频繁进行数据操作的表，不要建立太多的索引； 9、删除无用的索引，避免对执行计划造成负面影响；</p>
<h2 id="b-tree-原理与其它查找树的比较">B+ Tree 原理，与其它查找树的比较</h2>
<h3 id="b-tree-基本数据结构">B+ Tree 基本数据结构</h3>
<blockquote>
<p>B Tree</p>
</blockquote>
<p>B Tree 是指 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且<strong>所有叶子节点位于同一层</strong>。平衡树是改进的二叉查找树。一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了平衡树。</p>
<p>在这里，平衡指<strong>所有叶子的深度趋于平衡</strong>，更广义的是指在树上所有可能查找的均摊复杂度偏低。</p>
<p><img src="https://i.loli.net/2020/04/08/gqdZEF54wjiLAQ2.png" srcset="/img/loading.gif" alt="240px-AVLtreef.svg.png"  /></p>
<blockquote>
<p>B+ Tree</p>
</blockquote>
<p>B+树是B树的一种变形，它<strong>把数据都存储在叶子节点</strong>，内部的非叶子节点只存索引和孩子指针，<strong>以叶子节点的最小值作为索引（3，5）</strong>，简化了内部节点。B+树的遍历高效，将所有叶子节点串联成链表即可从头到尾遍历。</p>
<p>B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。下图是把键1-7连接到值 d1-d7 的B+树。链表指针（红色）用于快速顺序遍历叶子节点，空指针（黄色）为null，有效指针（白色）用于指向子节点或者数据（<span class="math inline">\(d_1\)</span>, <span class="math inline">\(d_2\)</span>, ..., <span class="math inline">\(d_7\)</span>）。</p>
<figure>
<img src="https://i.loli.net/2020/04/08/TKriSgRuay7GkhH.png" srcset="/img/loading.gif" alt="1024px-Bplustree.png" /><figcaption aria-hidden="true">1024px-Bplustree.png</figcaption>
</figure>
<p><strong>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现</strong>，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。（重点内容）</p>
<p>在 B+ Tree 中，一个节点中的 <span class="math inline">\(key\)</span>（<span class="math inline">\(key\)</span> 就是索引） 从左到右非递减排列，如果某个指针的左右相邻的 <span class="math inline">\(key\)</span> 分别是 <span class="math inline">\(key_i\)</span> (3) 和 <span class="math inline">\(key_{i+1}\)</span> (5)，且不为 null，则该指针指向节点的所有 <span class="math inline">\(key\)</span> (3、4) 大于等于 <span class="math inline">\(key_i\)</span> (3) 且小于等于 <span class="math inline">\(key_{i+1}\)</span> (5)。</p>
<blockquote>
<p>Differences of B Tree and B+ Tree</p>
</blockquote>
<ul>
<li>所有data都存储在叶子节点，非叶子节点不存储真正的data。</li>
<li>为所有叶子节点增加了一个链指针，将所有叶子节点串联成链表即可从头到尾遍历。</li>
</ul>
<h3 id="b-tree-操作">B+ Tree 操作</h3>
<blockquote>
<p>查找操作</p>
</blockquote>
<p>首先在根节点进行二分查找，找到一个 key 所在的指针，然后<strong>递归地在指针所指向的节点进行查找。</strong> 直到查找到叶子节点，<strong>然后在叶子节点上进行二分查找</strong>，找出 key 所对应的 data。</p>
<blockquote>
<p>插入操作</p>
</blockquote>
<p><code>M</code> 阶B+树插入：</p>
<ul>
<li>若为空树直接插入。</li>
<li>对于叶子结点：根据key找到叶子结点，对叶子结点进行插入操作。插入后如果当前叶子结点的key值数 <code>b</code> 不大于m-1，则插入结束。</li>
<li>对于索引结点：如果当前结点的key个数小于等于 <code>m-1</code> ，插入结束。</li>
</ul>
<blockquote>
<p>删除操作</p>
</blockquote>
<p>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个<strong>分裂、合并、旋转等操作</strong>（待详细补充）来维护平衡性。</p>
<h3 id="与其它查找树的比较">与其它查找树的比较</h3>
<blockquote>
<p>B+树与B树比较</p>
</blockquote>
<ul>
<li>B+树的磁盘读写代价更低</li>
</ul>
<p>因为B+树内部结点没有指向关键字具体信息的指针，内部结点相对B树小，B+树的磁盘读写代价就更低。</p>
<ul>
<li>B+树的查询更加稳定</li>
</ul>
<p>因为非终端结点并不是指向文件内容的结点，仅仅是作为叶子结点的关键字索引，因此所有的关键字查询都会走一条从根节点到叶子结点的路径。<strong>即所有关键字查询的长度是一样的，查询效率稳定。不会出现一会儿查询快、一会儿查询慢的情况。</strong></p>
<blockquote>
<p>B+树与红黑树的比较</p>
</blockquote>
<ul>
<li>B+树查找次数更少</li>
</ul>
<p>平衡树查找操作的时间复杂度和树高 h 相关，<span class="math inline">\(O(h)=O(logdN)\)</span>，其中 d 为每个节点的出度。</p>
<p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p>
<ul>
<li>B+树能够利用磁盘预读特性</li>
</ul>
<p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p>
<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。<strong>数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</strong>并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
<h2 id="查询优化">查询优化</h2>
<h3 id="使用-explain-进行分析">使用 Explain 进行分析</h3>
<p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。Explain可以分析某条select语句会查询多少条记录、以怎样的方式查询，以及复杂select的执行顺序，借此可以了解到select语句的性能和查询是如何执行的</p>
<p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<h3 id="优化数据访问">优化数据访问</h3>
<h4 id="减少请求的数据量">减少请求的数据量</h4>
<ul>
<li><strong>只返回必要的列</strong>：最好不要使用 SELECT * 语句。</li>
<li><strong>只返回必要的行</strong>：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h4 id="减少服务器端扫描的行数">减少服务器端扫描的行数</h4>
<p>最有效的方式是使用索引来覆盖查询。</p>
<h3 id="重构查询方式">重构查询方式</h3>
<h4 id="切分大查询">切分大查询</h4>
<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight n1ql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs n1ql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> messages <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">create</span> &lt; DATE_SUB(NOW(), INTERVAL <span class="hljs-number">3</span> MONTH);<br>rows_affected = 0<br>do &#123;<br>    rows_affected = do_query(<br>    &quot;<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> messages <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">create</span>  &lt; DATE_SUB(NOW(), INTERVAL <span class="hljs-number">3</span> MONTH) <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10000</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">&#125; while rows_affected &gt; 0</span><br></code></pre></div></td></tr></table></figure>
<h4 id="分解大连接查询">分解大连接查询</h4>
<p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> * FROM <span class="hljs-built_in">tag</span><br><span class="hljs-keyword">JOIN</span> tag_post <span class="hljs-keyword">ON</span> tag_post.tag_id=<span class="hljs-built_in">tag</span>.id<br><span class="hljs-keyword">JOIN</span> post <span class="hljs-keyword">ON</span> tag_post.post_id=post.id<br><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">tag</span>.<span class="hljs-built_in">tag</span>=<span class="hljs-string">&#x27;mysql&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> * FROM <span class="hljs-built_in">tag</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">tag</span>=<span class="hljs-string">&#x27;mysql&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> * FROM tag_post <span class="hljs-keyword">WHERE</span> tag_id=<span class="hljs-number">1234</span>;<br><span class="hljs-keyword">SELECT</span> * FROM post <span class="hljs-keyword">WHERE</span> post.id <span class="hljs-keyword">IN</span> (<span class="hljs-number">123</span>,<span class="hljs-number">456</span>,<span class="hljs-number">567</span>,<span class="hljs-number">9098</span>,<span class="hljs-number">8904</span>);<br></code></pre></div></td></tr></table></figure>
<h3 id="汇总">汇总</h3>
<ul>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。</li>
<li>应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：<code>select id from t where num is null</code> 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<code>select id fromt where num=0</code></li>
<li>应尽量避免在where子句中使用！=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li>
<li>应尽量<strong>避免在where子句中使用or来连接条件</strong>，否则<strong>将导致引擎放弃使用索引而进行全表扫描</strong>，如：<code>select id from t where num=10 or num=20</code> 可以这样查询：<code>select id from t where num=10 union all - select id from t where num=20</code></li>
<li>in 和 not in 也要慎用，否则会导致全表扫描，如：<code>select id fromt where num in(1, 2, 3)</code></li>
<li>索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li>
<li>应尽可能的避免更新clustered索引数据列，因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新clustered索引数据列，那么需要考虑是否应将该索引建为clustered索引：</li>
<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</li>
<li>尽可能的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</li>
<li>任何地方都不要使用select*fromt，用具体的字段列表代替“”，不要返回用不到的任何字段。</li>
<li>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</li>
<li>避免频繁创建和删除临时表，以减少系统表资源的消耗。</li>
<li>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</li>
<li>在新建临时表时，如果一次性插入数据量很大，那么可以使用select into代替create table，避免造成大量log，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert：</li>
<li>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先truncate table，然后drop table，这样可以避免系统表的较长时间锁定：尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</li>
<li>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</li>
<li>与临时表一样，游标并不是不可使用。对小型数据集使用FAST_FORWARD游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</li>
<li>在所有的存储过程和触发器的开始处设置SET NOCOUNTON，在结束时设置SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC消息。</li>
<li>尽量避免大事务操作，提高系统并发能力。</li>
<li>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</li>
</ul>
<h2 id="innodb-与-myisam-比较">InnoDB 与 MyISAM 比较</h2>
<p>Innodb</p>
<p>My Indexed Sequential Access Method （我的有索引的顺序访问方法） 读音类似 米森</p>
<blockquote>
<p>共同点</p>
</blockquote>
<p>都是数据库引擎</p>
<blockquote>
<p>基本的差别</p>
</blockquote>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Innodb</th>
<th>MySIAM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr class="even">
<td>体积</td>
<td>大，<strong>Innodb是索引和数据是紧密捆绑的</strong>，没有使用压缩从而会造成Innodb比MyISAM体积庞大不少。</td>
<td>小，<strong>MyISAM的索引和数据是分开的</strong>，并且<strong>支持压缩表和空间数据索引。</strong>内存使用率就对应提高了不少，能加载更多索引。</td>
</tr>
<tr class="odd">
<td>高级功能</td>
<td>支持，InnoDB提供<strong>事务管理支持</strong>、外键、包括行级锁在内的锁机制等高级数据库功能。</td>
<td>不支持事务管理、外键等功能，MyISAM 只支持表级锁，</td>
</tr>
<tr class="even">
<td>内存缓存</td>
<td>而lnnoDB缓存在内存的是数据，相对来说，<strong>服务器内存越大，InnoDB发挥的优势越大。</strong></td>
<td>MyISAM缓存在内存的是索引，不是数据。</td>
</tr>
<tr class="odd">
<td>备份</td>
<td>InnoDB 支持在线热备份</td>
<td>关闭服务器执行离线备份冷备份</td>
</tr>
<tr class="even">
<td>崩溃恢复</td>
<td>不易崩溃，基于日志系统能够快速恢复。</td>
<td>MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多</td>
</tr>
<tr class="odd">
<td>Mysql选择</td>
<td>从MySQL5.5.5以后，InnoDB是默认引擎。</td>
<td>MyISAM是MySQL5.5.5以前的默认引擎。</td>
</tr>
<tr class="even">
<td>应用场景</td>
<td>Innodb支持外键、行锁、事务是Innodb的最大特点。如果有大量的update和insert，建议使用InnoDB，特别是针对多个并发和QPS较高的情况。</td>
<td><strong>MySIAM是存储记录和文件的标准方法。</strong>不是事务安全的，而且不支持外键，如果执行大量的select，insert MyISAM比较适合。</td>
</tr>
</tbody>
</table>
<p>Innodb，功能全面更高级，写操作（update、insert）大量多于读操作（select）的场景。</p>
<p>MySIAM，功能简单，更快，读操作（select）大量多于写操作（update、insert）的场景。</p>
<blockquote>
<p>其他差别</p>
</blockquote>
<ul>
<li>从MySQL5.6版本开始，InnoDB开始支持FULLTEXT类型的索引，之前的版本不支持全文索引。</li>
<li>InnoDB中不保存表的行数，如select count（0）from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count（0）语句包含where条件时MyISAM也需要扫描整个表.</li>
<li>对于自增长的字段，在MylSAM表中可以和其他字段一起建立联合索引。在InnoDB中，可以创建只有该字段的索引，也可以建立联合索引，但自增键必须在最左侧。</li>
<li>清空整个表（delete from）时，InnoDB是一行一行的删除，效率非常慢。MylSAM则会重建表。（这个区别貌似不是很重要哈）</li>
<li>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</li>
<li>Innodb实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</li>
</ul>
<blockquote>
<p>参考链接</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/y-rong/p/8110596.html">MyISAM与InnoDB两者之间区别与选择，详细总结，性能对比</a></p>
<h2 id="水平切分与垂直切分">水平切分与垂直切分</h2>
<h2 id="主从复制原理作用实现">主从复制原理、作用、实现</h2>
<p>一致性 Hash</p>
<p>https://www.jianshu.com/p/e968c081f563</p>
<p>https://www.cnblogs.com/lpfuture/p/5796398.html</p>
<p>https://zhuanlan.zhihu.com/p/34985026</p>
<h2 id="redoundobinlog-日志的作用">redo、undo、binlog 日志的作用</h2>
<h1 id="redis">Redis</h1>
<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类keyvalue存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。</p>
<h2 id="使用场景">使用场景</h2>
<h3 id="计数器">计数器</h3>
<p>在内存中对数字进行自增自减运算，从而实现计数器功能。</p>
<p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<h3 id="通用缓存">通用缓存</h3>
<p>将热点数据放到内存中，<strong>设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</strong></p>
<h3 id="查找表">查找表</h3>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。</p>
<p><strong>查找表和缓存类似，也是利用了 Redis 快速的查找特性。</strong>但是<strong>查找表的内容不能失效，而缓存的内容可以失效</strong>，因为缓存不作为可靠的数据来源。</p>
<h3 id="消息队列">消息队列</h3>
<p>Redis 的 <code>List</code> 是一个双向链表，可以通过 <code>lpush</code> 和 <code>rpop</code> 写入和读取消息</p>
<p>不过最好使用 Kafka、RabbitMQ 等<strong>消息中间件。</strong></p>
<h3 id="会话缓存">会话缓存</h3>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息（session catch）。</p>
<p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ChinacloudTech/p/10719004.html">Django项目中使用Redis</a>连接和配置都已经完成了，那么在项目中该如何使用呢？接下来看下面这段例子吧。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><span class="hljs-keyword">from</span> django.core.cache <span class="hljs-keyword">import</span> cache<br><br><span class="hljs-comment"># read cache user id</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_from_cache</span>(<span class="hljs-params">self, user_name</span>):</span><br>    key = <span class="hljs-string">&#x27;user_id_of_&#x27;</span>+user_name<br>    value = cache.get(key)<br>    <span class="hljs-keyword">if</span> value == <span class="hljs-literal">None</span>:<br>        data = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        data = json.loads(value)<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-comment"># write cache user id</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_to_cache</span>(<span class="hljs-params">self, user_name</span>):</span><br>    key = <span class="hljs-string">&#x27;user_id_of_&#x27;</span>+user_name<br>    cache.<span class="hljs-built_in">set</span>(key, json.dumps(user_name), settings.NEVER_REDIS_TIMEOUT)<br></code></pre></div></td></tr></table></figure>
<p>通过上面的这两个方法就可以实现对redis的读取操作了，只需要将需要的字段当参数传入到方法中就好了。</p>
<h3 id="分布式锁实现">分布式锁实现</h3>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p>
<p>可以使用 Redis 自带的 <code>SETNX</code> 命令实现分布式锁，除此之外，还可以使用官方提供的 <code>RedLock</code> 分布式锁实现。</p>
<p>Redis <code>Setnx</code>（<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists） 命令在指定的 key 不存在时，为 key 设置指定的值。</p>
<h3 id="其它">其它</h3>
<p><code>Se</code>t 可以实现交集、并集等操作，<strong>从而实现共同好友等功能</strong>。</p>
<p><code>ZSet</code> 可以<strong>实现有序性操作</strong>，从而实现<strong>排行榜等功能</strong>。</p>
<h2 id="redis-与-memchached-的比较">Redis 与 Memchached 的比较</h2>
<blockquote>
<p>相同点</p>
</blockquote>
<p>两者都是非关系型内存键值数据库</p>
<blockquote>
<p>不同点</p>
</blockquote>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 63%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Redis</th>
<th>Memchached</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数据类型</td>
<td>Redis 支持五种不同的数据类型（String、Hash、List、Set、Zset），可以更灵活地解决问题。</td>
<td>Memcached 仅支持字符串类型</td>
</tr>
<tr class="even">
<td>数据持久化</td>
<td>Redis 支持两种持久化策略：RDB 快照和 AOF 日志</td>
<td>Memcached 不支持持久化</td>
</tr>
<tr class="odd">
<td>分布式</td>
<td>Redis Cluster 实现了分布式的支持。</td>
<td>Memcached 不支持分布式，只能通过在客户端使用<strong>一致性哈希</strong>来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</td>
</tr>
<tr class="even">
<td>内存管理机制</td>
<td>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。</td>
<td>而 Memcached 的数据则会一直在内存中。</td>
</tr>
<tr class="odd">
<td>网络I/O</td>
<td>单线程、I/O复用模型</td>
<td>多线程、I/O阻塞模型</td>
</tr>
<tr class="even">
<td>查询/操作类型</td>
<td>1、批量操作。2、事务支持。3、每个类型不同的CRUD。</td>
<td>常用CRUD、少量的命令</td>
</tr>
<tr class="odd">
<td>适用场景</td>
<td>复杂数据结构、持久化、高可用、Value存储较大。</td>
<td>纯key-value，数据量非常大，并发非常大的业务。</td>
</tr>
</tbody>
</table>
<h2 id="集群与分布式">集群与分布式</h2>
<h2 id="线程安全问题">线程安全问题</h2>
<h3 id="redis-是线程安全的吗">Redis 是线程安全的吗？</h3>
<p>Redis 是个单线程程序，所以它是线程安全的。</p>
<h3 id="redis-单线程为什么还能这么快">Redis 单线程为什么还能这么快？</h3>
<ul>
<li>Redis 是基于内存的，内存的读写速度非常快。</li>
<li>Redis 是单线程的，避免了不必要的上下文切换和竞争条件（不需要线程同步和线程通信，因此更节省时间）。</li>
<li>Redis 使用多路复用技术，可以处理并发的连接，非阻塞 I/O 内部实现采用 epoll。采用了 epoll + 自己实现的简单的事件框架。 epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 I/O上浪费一点时间。</li>
</ul>
<h3 id="为什么-redis-是单线程的">为什么 Redis 是单线程的？</h3>
<p><strong>1、官方回答</strong></p>
<p>因为Redis 是基于内存的操作， CPU 不是 Redis 的瓶颈， Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了，而且避免了线程同步、线程通信、线程切换带来的时间开销。</p>
<p><strong>2、性能更好</strong></p>
<p>关于Redis 的性能，官方网站也有，即使在普通笔记本这样的硬件上，Redis依然可以轻松处理每秒几十万的请求。</p>
<p><strong>3、详细原因</strong></p>
<p>3.1、不需要各种锁的性能消耗</p>
<p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p>
<p>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p>
<p>3.2、单线程多进程集群方案</p>
<p>单线程的威力实际上非常强大，核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p>
<p><strong>所以单线程、多进程的集群不失为一个合适的解决方案。</strong></p>
<p>3.3、CPU消耗</p>
<p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU。 但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p>
<p>可以考虑多起几个Redis 进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p>
<h2 id="字典和跳跃表原理分析">字典和跳跃表原理分析</h2>
<h3 id="字典">字典</h3>
<p>Dictht 是一个散列表结构（hash-map），<strong>Redis使用拉链法解决哈希冲突，也可以用再次hash或者开放地址hash来解决</strong>。</p>
<p><strong>开放定址法</strong>：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。</p>
<p><strong>链地址法</strong>：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。</p>
<p>字典又称符号表，关联数组或者映射，是一种用于保存键值对的抽象数据结构。字典中的每个键都是独一无二的，程序可以在字典中根据键值查找与之关联的值，或者通过键来更新值，删除等。</p>
<p>字典实现：Redis的字典使用哈希表作为底层实现，一个哈希表里面有多个哈希节点，而每个哈希表节点就保存了字典中的一个键值对。</p>
<blockquote>
<p>拉链法</p>
</blockquote>
<p>将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组t[0..m-1]。凡是散列地址为i的结点，均插入到以t为头指针的单链表中。t中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。</p>
<p>换句话说：HashCode是使用Key通过Hash函数计算出来的，由于不同的Key，通过此Hash函数可能会算的同样的HashCode，所以此时用了拉链法解决冲突，把HashCode相同的Value连成链表. 但是get的时候根据Key又去桶里找，如果是链表说明是冲突的，此时还需要检测Key是否相同</p>
<figure>
<img src="https://i.loli.net/2020/04/11/WEdyPoaGMBJfY8Q.jpg" srcset="/img/loading.gif" alt="v2-56a807e5ed10b5a2a025a7eacc58c3b2_720w 1.jpg" /><figcaption aria-hidden="true">v2-56a807e5ed10b5a2a025a7eacc58c3b2_720w <em>1</em>.jpg</figcaption>
</figure>
<p>在解释下，Java中HashMap是利用“拉链法”处理HashCode的碰撞问题。在调用HashMap的put方法或get方法时，都会首先调用hashcode方法，去查找相关的key，当有冲突时，再调用equals方法。hashMap基于hasing原理，我们通过put和get方法存取对象。当我们将键值对传递给put方法时，他调用键对象的hashCode()方法来计算hashCode，然后找到bucket（哈希桶）位置来存储对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当碰撞发生了，对象将会存储在链表的下一个节点中。hashMap在每个链表节点存储键值对对象。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37084847">知乎 安安熊</a></p>
<p>详情可参看 <a href="/2020/04/11/Redis字典详解/">Redis 字典详解</a></p>
<h3 id="跳表">跳表</h3>
<p>跳表原理可参看这个链接 <a target="_blank" rel="noopener" href="https://onclick.ac.cn/2020/04/07/跳表/">Redis 跳表详解</a></p>
<h3 id="redis的几种数据类型">Redis的几种数据类型</h3>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 27%" />
<col style="width: 30%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">类型</th>
<th style="text-align: left;">简介</th>
<th style="text-align: left;">特性</th>
<th style="text-align: left;">场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">String(字符串)</td>
<td style="text-align: left;">二进制安全</td>
<td style="text-align: left;">可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td>
<td style="text-align: left;">---</td>
</tr>
<tr class="even">
<td style="text-align: left;">Hash(字典)</td>
<td style="text-align: left;">键值对集合,即编程语言中的Map类型</td>
<td style="text-align: left;">适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td>
<td style="text-align: left;">存储、读取、修改用户属性</td>
</tr>
<tr class="odd">
<td style="text-align: left;">List(列表)</td>
<td style="text-align: left;">链表(双向链表)</td>
<td style="text-align: left;">增删快,提供了操作某一段元素的API</td>
<td style="text-align: left;">1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td>
</tr>
<tr class="even">
<td style="text-align: left;">Set(集合)</td>
<td style="text-align: left;">哈希表实现,元素不重复</td>
<td style="text-align: left;">1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td>
<td style="text-align: left;">1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Sorted Set/Zset(有序集合)</td>
<td style="text-align: left;">将Set中的元素增加一个权重参数score,元素按score有序排列</td>
<td style="text-align: left;">数据插入集合时,已经进行天然排序</td>
<td style="text-align: left;">1、排行榜 2、带权重的消息队列</td>
</tr>
</tbody>
</table>
<h2 id="rdb-和-aof-持久化机制">RDB 和 AOF 持久化机制</h2>
<p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<h3 id="rdb-持久化">RDB 持久化</h3>
<p><strong>将某个时间点的所有数据都存放到硬盘上。</strong></p>
<p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p>
<p><strong>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</strong></p>
<p>如果数据量很大，保存快照的<strong>时间会很长</strong>。</p>
<h3 id="aof-持久化">AOF 持久化</h3>
<p>将<strong>写命令添加到 AOF 文件（Append Only File）的末尾</strong>。</p>
<p>使用 AOF 持久化<strong>需要设置同步选项</strong>，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上执行（将内容同步到磁盘上），而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>同步频率</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>always</td>
<td>每个写命令都同步</td>
</tr>
<tr class="even">
<td>everysec</td>
<td>每秒同步一次</td>
</tr>
<tr class="odd">
<td>no</td>
<td>让操作系统来决定何时同步</td>
</tr>
</tbody>
</table>
<ul>
<li>always 选项会严重减低服务器的性能；</li>
<li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li>
<li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li>
</ul>
<p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
<h2 id="事件驱动模型">事件驱动模型</h2>
<p>Redis 服务器是一个事件驱动程序。</p>
<h3 id="文件事件">文件事件</h3>
<p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p>
<blockquote>
<p>实现方法</p>
</blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，<strong>使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</strong></p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/b570ff3264449fd72ba03e0c70ca02247cc4f283/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39656138366562352d303030612d343238312d623934382d3762353637626436663164382e706e67"><img src="https://camo.githubusercontent.com/b570ff3264449fd72ba03e0c70ca02247cc4f283/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39656138366562352d303030612d343238312d623934382d3762353637626436663164382e706e67" srcset="/img/loading.gif" alt="img" /></a></p>
<h3 id="时间事件">时间事件</h3>
<p><strong>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</strong></p>
<p>时间事件又分为：</p>
<ul>
<li>定时事件：是让一段程序在指定的时间之内执行一次；</li>
<li>周期性事件：是让一段程序每隔指定时间就执行一次。</li>
</ul>
<blockquote>
<p>实现方法</p>
</blockquote>
<p>Redis 将<strong>所有时间事件都放在一个无序链表中</strong>，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p>
<h3 id="事件的调度与执行">事件的调度与执行</h3>
<p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p>
<p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aeProcessEvents</span>():</span><br>    <span class="hljs-comment"># 获取到达时间离当前时间最接近的时间事件</span><br>    time_event = aeSearchNearestTimer()<br>    <span class="hljs-comment"># 计算最接近的时间事件距离到达还有多少毫秒</span><br>    remaind_ms = time_event.when - unix_ts_now()<br>    <span class="hljs-comment"># 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span><br>    <span class="hljs-keyword">if</span> remaind_ms &lt; <span class="hljs-number">0</span>:<br>        remaind_ms = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 根据 remaind_ms 的值，创建 timeval</span><br>    timeval = create_timeval_with_ms(remaind_ms)<br>    <span class="hljs-comment"># 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span><br>    aeApiPoll(timeval)<br>    <span class="hljs-comment"># 处理所有已产生的文件事件</span><br>    procesFileEvents()<br>    <span class="hljs-comment"># 处理所有已到达的时间事件</span><br>    processTimeEvents()<br></code></pre></div></td></tr></table></figure>
<p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 初始化服务器</span><br>    init_server()<br>    <span class="hljs-comment"># 一直处理事件，直到服务器关闭为止</span><br>    <span class="hljs-keyword">while</span> server_is_not_shutdown():<br>        aeProcessEvents()<br>    <span class="hljs-comment"># 服务器关闭，执行清理操作</span><br>    clean_server()<br></code></pre></div></td></tr></table></figure>
<p>从事件处理的角度来看，服务器运行流程如下：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/87a2045534a9a0cc2ba02a0e21581d85d2ca2b84/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63306139666139312d646132652d343839322d386339662d3830323036613666373034372e706e67"><img src="https://camo.githubusercontent.com/87a2045534a9a0cc2ba02a0e21581d85d2ca2b84/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63306139666139312d646132652d343839322d386339662d3830323036613666373034372e706e67" srcset="/img/loading.gif" alt="img" /></a></p>
<h2 id="数据淘汰机制">数据淘汰机制</h2>
<h3 id="淘汰过程">淘汰过程</h3>
<p>内存淘汰的过程：</p>
<ul>
<li>客户端发起了需要申请更多内存的命令（如set）</li>
<li>Redis 检查内存使用情况，如果已使用的内存大于 <code>max memory</code> 则开始根据用户配置的不同淘汰策略来淘汰内存（key），从而换取一定的内存。</li>
<li>如果上面都没问题，则这个命令执行成功。</li>
</ul>
<h3 id="lru最近最久未使用算法-least-recently-used">LRU（最近最久未使用算法 Least Recently Used）</h3>
<p>在一小部分缓存的key-value中找到最近最久未使用的那个key-value，将其淘汰。</p>
<h3 id="ttl生存时间值-time-to-live">TTL（生存时间值 Time To Live）</h3>
<p>把存在时间大于TTL的key-value全部淘汰掉。</p>
<h3 id="redis-具体有-6-种淘汰策略">Redis 具体有 6 种淘汰策略</h3>
<table>
<thead>
<tr class="header">
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>volatile-lru</td>
<td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr class="even">
<td>volatile-ttl</td>
<td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr class="odd">
<td>volatile-random</td>
<td>从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr class="even">
<td>allkeys-lru</td>
<td>从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr class="odd">
<td>allkeys-random</td>
<td>从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr class="even">
<td>noeviction</td>
<td>禁止驱逐数据</td>
</tr>
</tbody>
</table>
<h3 id="总结">总结</h3>
<p>Redis中的淘汰机制（LRU和TTL）都是<strong>非精确算法</strong>实现的，主要从性能和可靠性上做平衡，所以并不是完全可靠，在了解Redis 淘汰策略之后还应在平时多<strong>主动设置或更新key的expire时间</strong>，主动删除没有价值的数据，提升Redis整体性能和空间。</p>
<p>作为内存数据库，出于对性能和内存消耗的考虑，<strong>Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。（这个很关键）</strong></p>
<p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 <code>allkeys-lru</code> 淘汰策略，将最近最少使用的数据淘汰。</p>
<p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
<h2 id="事务原理">事务原理</h2>
<p>Redis的一个事务包含了多个不可分割的命令，要么一起执行要么都不执行，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p>
<p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p>
<p>redis事务从开始到结束，一般会经过三个阶段：</p>
<ul>
<li>事务开始</li>
<li>命令入队</li>
<li>事务执行</li>
</ul>
<p>Redis 最简单的事务实现方式是使用 <code>MULTI</code> 和 <code>EXEC</code> 命令将事务操作包围起来。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi <br>OK<br>127.0.0.1:6379&gt; lpush fruits orange<br>QUEUED<br>127.0.0.1:6379&gt; lpush fruits nut<br>QUEUED<br>127.0.0.1:6379&gt; lpush fruits apple<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><br>1) (<span class="hljs-built_in">integer</span>) 1<br>2) (<span class="hljs-built_in">integer</span>) 2<br>3) (<span class="hljs-built_in">integer</span>) 3<br></code></pre></div></td></tr></table></figure>
<p>出现并发问题，因为有多个客户端会并发进行操作。我们可以通过 Redis 的分布式锁来避免冲突，这是一个很好的解决方案。<strong>分布式锁是一种悲观锁</strong>。</p>
<p>那是不是可以使用乐观锁的方式来解决冲突呢？ Redis 提供了这种 <code>watch</code> 的机制，它就是一种乐观锁。有了 <code>watch</code> 我们又多了一种可以用来解决并发修改的方法。 <code>watch</code> 的使用方式如下：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; watch msg<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; multi<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; set msg <span class="hljs-string">&quot;hello wolrd&quot;</span><br>QUEUED<br><span class="hljs-number">127.0.0.1:6379</span>&gt; exec<br>(nil)<br><span class="hljs-number">127.0.0.1:6379</span>&gt; get msg<br><span class="hljs-string">&quot;12345&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; <br></code></pre></div></td></tr></table></figure>
<p>注意事项 Redis 禁止在 multi 和 exec 之间执行 watch 指令，而必须在 multi 之前做好盯住关键变量，否则会出错。</p>
<blockquote>
<p>总结</p>
</blockquote>
<p>事务队列以先进先出的方法保存命令，先入队的命令会被放到队列的前面，而较后入队的命令则会被放到队列的后面。通过悲观锁机制对队列上锁，或者通过<code>watch</code>命令在开始时就盯住关键变量（使用乐观锁），可以解决并发问题，保证事务队列中的命令一起执行。</p>
<blockquote>
<p>参考连接</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tangge/p/10753859.html">Redis实战 - 5事务：multi、exec和watch</a></p>
<h2 id="主从复制原理">主从复制原理</h2>
<p>面试真题：Redis哨兵模型、部署、原理，怎么选从服务器？</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%85%A5%E9%97%A8/">计算机科学入门</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/04/08/%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%88TPS%EF%BC%89%E3%80%81QPS%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%EF%BC%88RT%EF%BC%89%E6%A6%82%E5%BF%B5/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">吞吐量（TPS）、QPS、并发数、响应时间（RT）概念</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/04/07/%E8%B7%B3%E8%A1%A8/">
                        <span class="hidden-mobile">Redis 跳表详解</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function() {
        this.page.url = 'http://example.com/2020/04/07/Mysql%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/';
        this.page.identifier = '/2020/04/07/Mysql%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/';
      };
      Fluid.utils.waitElementVisible('disqus_thread', function () {
        var d = document, s = d.createElement('script');
        s.src = '//' + 'codesisart' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', new Date());
        (d.head || d.body).appendChild(s);
      });
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>

<!-- <script type="text/javascript" src="/js/cdnjs.cloudflare.com_ajax_libs_mathjax_2.7.1_MathJax.js_config=TeX-MML-AM_CHTML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->


</body>
</html>
