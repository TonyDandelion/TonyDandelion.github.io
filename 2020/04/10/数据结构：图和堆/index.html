

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&quot;dark&quot;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="知无涯者">
  <meta name="keywords" content="">
  <title>数据结构：图和堆 - 代码即艺术</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/monokai.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>代码即艺术</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/introduction/">
                <i class="iconfont icon-map"></i>
                入门
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/404page.html">
                <i class="iconfont icon-heartbeat"></i>
                公益404
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数据结构：图和堆">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-04-10 20:53" pubdate>
        2020年4月10日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      51
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据结构：图和堆</h1>
            
            <div class="markdown-body">
              <p>记录图和堆有关的基础概念及相关算法</p>
<a id="more"></a>
<h1 id="图">图</h1>
<h2 id="图的基本概念">图的基本概念</h2>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nevermoes/p/9872877.html">数据结构-图</a></p>
<p>无向完全图中，n 个点则有 n(n-1)/2 条边。 有向完全图中，n 个点则有 n(n-1) 条边。</p>
<h2 id="图的遍历">图的遍历</h2>
<figure>
<img src="https://i.loli.net/2020/05/11/YVGcOyjJ4Fb7R1I.jpg" srcset="/img/loading.gif" alt="v2-ee45526da273f5c0fde827480913e29e_720w" /><figcaption aria-hidden="true">v2-ee45526da273f5c0fde827480913e29e_720w</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">graph = &#123;<br>        <span class="hljs-string">&#x27;a&#x27;</span> : [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>],<br>        <span class="hljs-string">&#x27;b&#x27;</span> : [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>],<br>        <span class="hljs-string">&#x27;c&#x27;</span> : [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>],<br>        <span class="hljs-string">&#x27;d&#x27;</span> : [<span class="hljs-string">&#x27;b&#x27;</span> , <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>],<br>        <span class="hljs-string">&#x27;e&#x27;</span> : [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>],<br>        <span class="hljs-string">&#x27;f&#x27;</span> : [<span class="hljs-string">&#x27;d&#x27;</span>]<br>        &#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="dfs">DFS</h3>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 循环</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DFS</span>(<span class="hljs-params">graph, s</span>):</span><br>    stack = []<br>    stack.append(s)<br>    seen = <span class="hljs-built_in">set</span>()<br>    seen.add(s)<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span>:<br>        vertex = stack.pop()<br>        nodes  = graph[vertex]<br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodes:<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:<br>                stack.append(node)<br>                seen.add(node)<br>        print(vertex)<br><br>DFS(graph, <span class="hljs-string">&#x27;a&#x27;</span>)<br><br><br><span class="hljs-comment"># 递归</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DFS1</span>(<span class="hljs-params">graph, s, queue=[]</span>):</span><br>    queue.append(s)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> graph[s]:<br>        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> queue:<br>            DFS1(graph, i, queue)<br>    <span class="hljs-keyword">return</span> queue<br><br>DFS1(graph, <span class="hljs-string">&#x27;a&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<h3 id="bfs">BFS</h3>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">![v2-94d2ac8ba296ef97477b0001a996104a_720w](C:\Users\Tommy\3D Objects\v2-94d2ac8ba296ef97477b0001a996104a_720w.jpgdef BFS(graph, s):<br>    queue = []<br>    queue.append(s)<br>    seen = <span class="hljs-built_in">set</span>()<br>    seen.add(s)<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>:<br>        vertex = queue.pop(<span class="hljs-number">0</span>)<br>        nodes = graph[vertex]<br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodes:<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:<br>                queue.append(node)<br>                seen.add(node)<br>        print(vertex)<br>        <br>BFS(graph, <span class="hljs-string">&#x27;a&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<h2 id="有权图中最短路径问题">有权图中最短路径问题</h2>
<figure>
<img src="https://i.loli.net/2020/05/11/4X6VIOiduSwEl7s.jpg" srcset="/img/loading.gif" alt="v2-94d2ac8ba296ef97477b0001a996104a_720w" /><figcaption aria-hidden="true">v2-94d2ac8ba296ef97477b0001a996104a_720w</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">inf = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>matrix_distance = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">12</span>,inf,inf,inf],<br>                   [inf,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,inf,inf],<br>                   [inf,inf,<span class="hljs-number">0</span>,inf,<span class="hljs-number">5</span>,inf],<br>                   [inf,inf,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>],<br>                   [inf,inf,inf,inf,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>],<br>                   [inf,inf,inf,inf,inf,<span class="hljs-number">0</span>]]<br></code></pre></div></td></tr></table></figure>
<h3 id="dijkstra算法">Dijkstra算法</h3>
<p>迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。<strong>是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。</strong>迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。</p>
<p>这里我们需要用到三个辅助数组：</p>
<ul>
<li><code>dist[vi]</code>，从 v0 到每个顶点 vi 的最短路径长度。</li>
<li><code>path[vi]</code>，保存从 v0 到 vi 最短路径上的前一个顶点。</li>
<li><code>set[]</code>，<strong>标记点是否被并入最短路径</strong>。</li>
</ul>
<p>执行过程：</p>
<ul>
<li>初始化：
<ul>
<li>选定源点 v0。</li>
<li>dist[vi]：若 v0 到 vi 之间若存在边，则为边上的权值，否则为∞。</li>
<li>path[vi]：若 v0 到 vi 之间存在边，则 path[vi]=v0，否则为-1。</li>
<li>set[v0]=TRUE，其余为 FALSE。</li>
</ul></li>
<li>执行：
<ol type="1">
<li>从当前的 dist[]数组中选出<strong>最小值 dist[vu]</strong>。</li>
<li>将 set[vu] 置为TRUE。</li>
<li>检测所有 set[vi]==FALSE 的点。</li>
<li>比较 dist[vi] 和 dist[vu]+w 的大小，w 为 &lt;vu,vi&gt;的权值。</li>
<li>如果 dist[vu]+w&lt;dist[vi]</li>
<li>更新 path[] 并将 vu 加入路径中</li>
<li>直到遍历完所有的顶点(n-1次)</li>
</ol></li>
</ul>
<p>结合图来理解就是：</p>
<figure>
<img src="https://i.loli.net/2020/05/11/oVpKQwvYbmE9T1q.png" srcset="/img/loading.gif" alt="1139760-20181025102953586-1615580793" /><figcaption aria-hidden="true">1139760-20181025102953586-1615580793</figcaption>
</figure>
<figure>
<img src="https://i.loli.net/2020/05/11/JOGIEeNA4kxga1L.png" srcset="/img/loading.gif" alt="1139760-20181025103032940-108172764" /><figcaption aria-hidden="true">1139760-20181025103032940-108172764</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dijkstra</span>(<span class="hljs-params">matrix_distance, source_node</span>):</span><br>    inf = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>    <span class="hljs-comment"># init the source node distance to others</span><br>    dis = matrix_distance[source_node]<br>    node_nums = <span class="hljs-built_in">len</span>(dis)<br>    <br>    flag = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(node_nums)]<br>    flag[source_node] = <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(node_nums-<span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">min</span> = inf<br>        <span class="hljs-comment">#find the min node from the source node</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(node_nums):<br>            <span class="hljs-keyword">if</span> flag[j] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> dis[j] &lt; <span class="hljs-built_in">min</span>:<br>                <span class="hljs-built_in">min</span> = dis[j]<br>                u = j<br>        flag[u] = <span class="hljs-number">1</span><br>        <span class="hljs-comment">#update the dis </span><br>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(node_nums):<br>            <span class="hljs-keyword">if</span> flag[v] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> matrix_distance[u][v] &lt; inf:<br>                <span class="hljs-keyword">if</span> dis[v] &gt; dis[u] + matrix_distance[u][v]:<br>                    dis[v] = dis[u] + matrix_distance[u][v]                    <br>    <br>    <span class="hljs-keyword">return</span> dis<br><br>dijkstra(matrix_distance, <span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>
<h3 id="floyd算法">Floyd算法</h3>
<p>Floyd算法又称为插点法，<strong>是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法</strong>，与Dijkstra算法类似。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。</p>
<ul>
<li>初始化一个矩阵 <span class="math inline">\(A\)</span>，<span class="math inline">\((A^{(-1)})[i][j]=G.edges[i][j]\)</span>。</li>
<li>迭代n轮：<span class="math inline">\((A^{(k)})=Min{(A^{(k-1)})[i][j], (A^{(k-1)})[i][k]+(A^{(k-1)})[k][j]}\)</span></li>
</ul>
<p><span class="math inline">\((A^{(k)})\)</span>矩阵存储了前K个节点之间的最短路径，基于最短路径的性质，<strong>第K轮迭代的时候会求出第K个节点到其他K-1个节点的最短路径。</strong></p>
<figure>
<img src="https://i.loli.net/2020/05/11/FJrgx6D9l7bRLHQ.png" srcset="/img/loading.gif" alt="1139760-20181025134249477-410650124" /><figcaption aria-hidden="true">1139760-20181025134249477-410650124</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Floyd</span>(<span class="hljs-params">dis</span>):</span><br>    <span class="hljs-comment"># min (Dis(i,j) , Dis(i,k) + Dis(k,j) )</span><br>    nums_vertex = <span class="hljs-built_in">len</span>(dis[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_vertex):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_vertex):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_vertex):<br>                <span class="hljs-keyword">if</span> dis[i][j] &gt; dis[i][k] + dis[k][j]:<br>                    dis[i][j] = dis[i][k] + dis[k][j]<br>    <span class="hljs-keyword">return</span> dis<br>print(Floyd(matrix_distance))<br></code></pre></div></td></tr></table></figure>
<h2 id="最小生成树问题">最小生成树问题</h2>
<p>假设以下情景，有一块木板，板上钉上了一些钉子，这些钉子可以由一些细绳连接起来。假设每个钉子可以通过一根或者多根细绳连接起来，那么一定存在这样的情况，即用最少的细绳把所有钉子连接起来。 更为实际的情景是这样的情况，在某地分布着<code>N</code>个村庄，现在需要在<code>N</code>个村庄之间修路，每个村庄之前的距离不同，问怎么修最短的路，将各个村庄连接起来。 以上这些问题都可以归纳为最小生成树问题，用正式的表述方法描述为：给定一个无方向的带权图<code>G=(V, E)</code>，最小生成树为集合<code>T</code>, <code>T</code>是以最小代价连接<code>V</code>中所有顶点所用边<code>E</code>的最小集合。 集合<code>T</code>中的边能够形成一颗树，这是因为每个节点（除了根节点）都能向上找到它的一个父节点。</p>
<p>解决最小生成树问题已经有前人开道，<code>Prime</code>算法和<code>Kruskal</code>算法，分别从点和边下手解决了该问题。</p>
<h3 id="prim算法">Prim算法</h3>
<p><code>Prim</code>算法是一种产生最小生成树的算法。该算法于<code>1930</code>年由捷克数学家沃伊捷赫·亚尔尼克（英语：<code>Vojtěch Jarník</code>）发现；并在<code>1957</code>年由美国计算机科学家罗伯特·普里姆（英语：<code>Robert C. Prim</code>）独立发现；<code>1959</code>年，艾兹格·迪科斯彻再次发现了该算法。</p>
<p><code>Prim</code>算法从任意一个顶点开始，每次选择一个与当前顶点集最近的一个顶点，并将两顶点之间的边加入到树中。<code>Prim</code>算法在找当前最近顶点时使用到了贪婪算法。<strong>适合于边稠密的图。</strong></p>
<p><strong><em>算法描述</em></strong></p>
<ol type="1">
<li>在一个加权连通图中，顶点集合<code>V</code>，边集合为<code>E</code></li>
<li>任意选出一个点作为初始顶点,标记为<code>visit</code>,计算所有与之相连接的点的距离，选择距离最短的，标记<code>visit</code>.</li>
<li>重复以下操作，直到所有点都被标记为<code>visit</code>： 在剩下的点钟，计算与已标记<code>visit</code>点距离最小的点，标记<code>visit</code>,证明加入了最小生成树。</li>
</ol>
<figure>
<img src="https://i.loli.net/2020/05/11/JQ2aCEqY3z4gobZ.png" srcset="/img/loading.gif" alt="1139760-20181009152355508-535468775" /><figcaption aria-hidden="true">1139760-20181009152355508-535468775</figcaption>
</figure>
<p><strong><em>代码</em></strong></p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><span class="hljs-keyword">from</span> heapq <span class="hljs-keyword">import</span> *<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Prim</span>(<span class="hljs-params">vertexs, edges, start_node</span>):</span><br>    adjacent_vertex = defaultdict(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">for</span> v1, v2, length <span class="hljs-keyword">in</span> edges:<br>        adjacent_vertex[v1].append((length, v1, v2))<br>        adjacent_vertex[v2].append((length, v2, v1))<br>        <br>    mst = []<br>    closed = <span class="hljs-built_in">set</span>(start_node)<br>    <br>    adjacent_vertexs_edges = adjacent_vertex[start_node]<br>    heapify(adjacent_vertexs_edges)<br><br>    <span class="hljs-keyword">while</span> adjacent_vertexs_edges:<br>        w, v1, v2 = heappop(adjacent_vertexs_edges)<br>        <span class="hljs-keyword">if</span> v2 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> closed:<br>            closed.add(v2)<br>            mst.append((v1, v2, w))<br>            <br>            <span class="hljs-keyword">for</span> next_vertex <span class="hljs-keyword">in</span> adjacent_vertex[v2]:<br>                <span class="hljs-keyword">if</span> next_vertex[<span class="hljs-number">2</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> closed:<br>                    heappush(adjacent_vertexs_edges, next_vertex)<br>                    <br>    <span class="hljs-keyword">return</span> mst<br>    <br>    <br>vertexs = <span class="hljs-built_in">list</span>(<span class="hljs-string">&quot;ABCDEFG&quot;</span>)<br>edges = [ (<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">7</span>), (<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-number">5</span>),<br>          (<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">8</span>), (<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-number">9</span>), <br>          (<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-number">7</span>), (<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-number">5</span>),<br>          (<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-number">15</span>), (<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-number">6</span>),<br>          (<span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-number">8</span>), (<span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;G&quot;</span>, <span class="hljs-number">9</span>),<br>          (<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;G&quot;</span>, <span class="hljs-number">11</span>)]<br><br>print(<span class="hljs-string">&#x27;prim:&#x27;</span>, Prim(vertexs, edges, <span class="hljs-string">&#x27;A&#x27;</span>))<br></code></pre></div></td></tr></table></figure>
<h3 id="kruskal算法">Kruskal算法</h3>
<p>Kruskal是另一个计算最小生成树的算法，其算法原理如下。首先，将每个顶点放入其自身的数据集合中。然后，按照权值的升序来选择边。当选择每条边时，判断定义边的顶点是否在不同的数据集中。如果是，将此边插入最小生成树的集合中，同时，将集合中包含每个顶点的联合体取出，如果不是，就移动到下一条边。重复这个过程直到所有的边都探查过。<strong>适合边少点多的图。</strong></p>
<figure>
<img src="https://i.loli.net/2020/05/11/HeKvnDLQdXWcpBA.png" srcset="/img/loading.gif" alt="1139760-20181009152448537-1374278496" /><figcaption aria-hidden="true">1139760-20181009152448537-1374278496</figcaption>
</figure>
<p><strong><em>代码</em></strong></p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">node = <span class="hljs-built_in">dict</span>()  <span class="hljs-comment"># 保存节点</span><br>rank = <span class="hljs-built_in">dict</span>()<br><br><span class="hljs-comment"># 创建集合</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_set</span>(<span class="hljs-params">point</span>):</span><br>    node[point] = point<br>    rank[point] = <span class="hljs-number">0</span><br>    <br><span class="hljs-comment"># 标记已经处理了的节点</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">point</span>):</span><br>    <span class="hljs-keyword">if</span> node[point] != point:<br>        node[point] = find(node[point])<br>    <span class="hljs-keyword">return</span> node[point]<br><br><span class="hljs-comment"># 合并两个节点</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">point1, point2</span>):</span><br>    root1 = find(point1)<br>    root2 = find(point2)<br>    <span class="hljs-keyword">if</span> root1 != root2:<br>        <span class="hljs-keyword">if</span> rank[root1] &gt; rank[root2]:<br>            node[root2] = root1<br>        <span class="hljs-keyword">else</span>:<br>            node[root1] = root2<br>            <span class="hljs-keyword">if</span> rank[root1] == rank[root2]: <br>                rank[root2] += <span class="hljs-number">1</span><br>            <br><span class="hljs-comment"># 主函数    </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Kruskal</span>(<span class="hljs-params">graph</span>):</span><br>    <span class="hljs-keyword">for</span> vertice <span class="hljs-keyword">in</span> graph[<span class="hljs-string">&#x27;vertices&#x27;</span>]:<br>        make_set(vertice)<br>    <br>    mst = <span class="hljs-built_in">set</span>()<br>    <br>    edges = <span class="hljs-built_in">list</span>(graph[<span class="hljs-string">&#x27;edges&#x27;</span>])<br>    edges.sort()<br>    <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> edges:<br>        weight, v1, v2 = edge<br>        <span class="hljs-keyword">if</span> find(v1) != find(v2):<br>            merge(v1 , v2)<br>            mst.add(edge)<br>    <span class="hljs-keyword">return</span> mst<br><br>graph = &#123;<br>    <span class="hljs-string">&#x27;vertices&#x27;</span>: [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>],<br>    <span class="hljs-string">&#x27;edges&#x27;</span>: <span class="hljs-built_in">set</span>([<br>        (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>),<br>        (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>),<br>        (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>),<br>        (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>),<br>        (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>),<br>        (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>),<br>        ])<br>    &#125;<br><br>print(Kruskal(graph))<br></code></pre></div></td></tr></table></figure>
<h2 id="一张图看懂数据结构图">一张图看懂数据结构——图</h2>
<figure>
<img src="https://i.loli.net/2020/05/11/Og3JfeQWbRahIk5.png" srcset="/img/loading.gif" alt="20200508105556140" /><figcaption aria-hidden="true">20200508105556140</figcaption>
</figure>
<h2 id="参考连接">参考连接</h2>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61628249">Python实现图的经典DFS、BFS、Dijkstra、Floyd、Prim、Kruskal算法</a> 关于<strong>最小生成树</strong>算法，推荐这个博客，讲的很清楚！ 作者：卡巴拉的树 链接：https://www.jianshu.com/p/efcd21494dff 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41413511/article/details/105953993">一张图看懂数据结构 —— k图</a></p>
<h1 id="堆">堆</h1>
<p>最大堆（大根堆）的定义：</p>
<ul>
<li>最大堆中的<strong>最大元素值</strong>出现在根结点（堆顶）</li>
<li>堆中每个父节点的元素值都<strong>大于等于</strong>其孩子结点</li>
</ul>
<p>最小堆（小根堆）的定义：</p>
<ul>
<li>最大堆中的<strong>最小元素值</strong>出现在根结点（堆顶）</li>
<li>堆中每个父节点的元素值都<strong>小于等于</strong>其孩子结点</li>
</ul>
<figure>
<img src="https://i.loli.net/2020/04/05/CnHVsfE5pu3L1GQ.png" srcset="/img/loading.gif" alt="650075-91f1549ff0c87c15.png" /><figcaption aria-hidden="true">650075-91f1549ff0c87c15.png</figcaption>
</figure>
<p>时间复杂度：</p>
<ul>
<li>大根堆获取最大值的操作，时间复杂度为 <span class="math inline">\(O(1)\)</span>。</li>
<li>堆的插入和删除操作，时间复杂度为 <span class="math inline">\(O(logN)\)</span> ，<span class="math inline">\(N\)</span> 是节点个数。</li>
</ul>
<h2 id="堆的基础操作">堆的基础操作</h2>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">heap</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        初始化一个空堆，使用数组来在存放堆元素，节省存储</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        self.data_list = []<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_parent_index</span>(<span class="hljs-params">self, index</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        返回父节点的下标</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt; <span class="hljs-built_in">len</span>(self.data_list) - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> (index - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span> <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swap</span>(<span class="hljs-params">self,index_a, index_b</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        交换数组中的两个元素</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        self.data_list[index_a],self.data_list[index_b] = self.data_list[index_b],self.data_list[index_a] <br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span>(<span class="hljs-params">self, data</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        先把元素放在最后，然后从后往前依次堆化</span><br><span class="hljs-string">        这里以大顶堆为例，如果插入元素比父节点大，则交换，直到最后</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        self.data_list.append(data)<br>        index = <span class="hljs-built_in">len</span>(self.data_list) - <span class="hljs-number">1</span> <br>        parent = self.get_parent_index(index)<br>        <span class="hljs-comment"># 循环，直到该元素成为堆顶，或小于父节点（对于大顶堆) </span><br>        <span class="hljs-keyword">while</span> parent <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> self.data_list[parent] &lt; self.data_list[index]:<br>            <span class="hljs-comment"># 交换操作</span><br>            self.swap(parent,index)<br>            index = parent<br>            parent = self.get_parent_index(parent)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeMax</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        删除堆顶元素，然后将最后一个元素放在堆顶，再从上往下依次堆化</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.data_list) &gt; <span class="hljs-number">0</span>:<br>            remove_data = self.data_list[<span class="hljs-number">0</span>]<br>            self.data_list[<span class="hljs-number">0</span>] = self.data_list[-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">del</span> self.data_list[-<span class="hljs-number">1</span>]<br>            <span class="hljs-comment">#堆化</span><br>            self.heapify(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> remove_data<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&#x27;堆空&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">self, index</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        从上往下堆化，从index 开始堆化操作 (大顶堆)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        total_index = <span class="hljs-built_in">len</span>(self.data_list) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            maxvalue_index = index<br>            <span class="hljs-keyword">if</span> <span class="hljs-number">2</span>*index + <span class="hljs-number">1</span> &lt;=  total_index <span class="hljs-keyword">and</span> self.data_list[<span class="hljs-number">2</span>*index + <span class="hljs-number">1</span>] &gt; self.data_list[maxvalue_index]:<br>                maxvalue_index = <span class="hljs-number">2</span>*index + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-number">2</span>*index + <span class="hljs-number">2</span> &lt;=  total_index <span class="hljs-keyword">and</span> self.data_list[<span class="hljs-number">2</span>*index + <span class="hljs-number">2</span>] &gt; self.data_list[maxvalue_index]:<br>                maxvalue_index = <span class="hljs-number">2</span>*index + <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> maxvalue_index == index:<br>                <span class="hljs-keyword">break</span><br>            self.swap(index,maxvalue_index)<br>            index = maxvalue_index<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMax</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        获取堆顶元素</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.data_list) &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> self.data_list[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&#x27;堆空&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    myheap = heap()<br>    <span class="hljs-comment"># nums = [6, 4, 5, 1, 9, 2, 7, 3, 8]</span><br>    nums = [<span class="hljs-number">6</span>]<br>    print(<span class="hljs-string">&quot;输入数据：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(nums))<br>    print(<span class="hljs-string">&quot;开始建堆&quot;</span>)<br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>        myheap.insert(num)<br>    print(<span class="hljs-string">&quot;建堆完成:&quot;</span>, myheap.data_list)<br>    print(<span class="hljs-string">&quot;获得堆顶元素：&quot;</span>, myheap.getMax())<br>    print(<span class="hljs-string">&quot;当前的堆:&quot;</span>, myheap.data_list)<br>    print(<span class="hljs-string">&quot;删除堆顶元素：&quot;</span>, myheap.removeMax())<br>    print(<span class="hljs-string">&quot;删除之后的堆:&quot;</span>, myheap.data_list)<br>    print(<span class="hljs-string">&quot;删除堆顶元素：&quot;</span>, myheap.removeMax())<br>    print(<span class="hljs-string">&quot;删除之后的堆:&quot;</span>, myheap.data_list)<br></code></pre></div></td></tr></table></figure>
<h2 id="python内建的heap">Python内建的Heap</h2>
<p>Python 中 <code>heapq</code> 模块是小顶堆。实现 <strong>大顶堆</strong> 方法： 小顶堆的插入和弹出操作均将元素 <strong>取反</strong> 即可。<strong>通过把元素取反再放入堆，出堆时再取反，</strong>把问题转换为最小堆问题也能间接实现最大堆</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> heapq <span class="hljs-keyword">import</span> *<br><br>minHeap = []<br>maxHeap = []<br><br><span class="hljs-comment"># 插入小顶堆</span><br>num = <span class="hljs-number">100</span><br>heappush(minHeap, num)<br><span class="hljs-comment"># 弹出小顶堆</span><br>heappop(minHeap)<br><br>num = <span class="hljs-number">150</span><br><span class="hljs-comment"># 插入大顶堆</span><br>heappush(maxHeap, -num)<br><span class="hljs-comment"># 弹出大顶堆</span><br>-heappop(maxHeap)<br></code></pre></div></td></tr></table></figure>
<p>常用函数</p>
<table>
<thead>
<tr class="header">
<th>函 数</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>heappush(heap, x)</td>
<td>将x压入堆中</td>
</tr>
<tr class="even">
<td>heappop(heap)</td>
<td>从堆中弹出最小的元素</td>
</tr>
<tr class="odd">
<td>heapify(heap)</td>
<td> 让列表具备堆特征</td>
</tr>
<tr class="even">
<td>heapreplace(heap, x)</td>
<td> 弹出最小的元素，并将x压入堆中</td>
</tr>
<tr class="odd">
<td>nlargest(n, iter)</td>
<td> 返回iter中n个最大的元素</td>
</tr>
<tr class="even">
<td>nsmallest(n, iter)</td>
<td> 返回iter中n个最小的元素</td>
</tr>
</tbody>
</table>
<h2 id="堆排序">堆排序</h2>
<p>堆排序是一种基于二叉堆（Binary Heap）结构的排序算法，所谓二叉堆，就是一种特殊的完全二叉树，只不过相比较完全二叉树而言，二叉堆的所有父节点的值都大于（或者小于）它的孩子节点，像这样：</p>
<figure>
<img src="https://i.loli.net/2020/04/05/rPs7YM2T9xlcKHE.jpg" srcset="/img/loading.gif" alt="v2-5d6119c9801eadb83402ef68f6d4b689_720w.jpg" /><figcaption aria-hidden="true">v2-5d6119c9801eadb83402ef68f6d4b689_720w.jpg</figcaption>
</figure>
<p>堆排序算法的内容就很简单了，<strong>最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 堆排序</span><br> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">heapSort</span>(<span class="hljs-params">self, nums</span>):</span><br>     <span class="hljs-comment"># 交换list中的两个元素</span><br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swap</span>(<span class="hljs-params">nums, i, j</span>):</span><br>         tmp = nums[i]<br>         nums[i] = nums[j]<br>         nums[j] = tmp<br><br>     <span class="hljs-comment"># 调整堆</span><br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">nums, n, i</span>):</span>  <span class="hljs-comment"># nums是数组、n是要调整的区间长度，i是要调整的根节点下标。</span><br>         largest = i<br>         l = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>  <span class="hljs-comment"># 左节点</span><br>         r = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>  <span class="hljs-comment"># 右节点</span><br>         <span class="hljs-keyword">if</span> l &lt; n <span class="hljs-keyword">and</span> nums[l] &gt; nums[largest]:  <span class="hljs-comment"># 如果 left 比 root 大的话，l&lt;n用于控制调整区间。</span><br>             largest = l<br>         <span class="hljs-keyword">if</span> r &lt; n <span class="hljs-keyword">and</span> nums[r] &gt; nums[largest]:  <span class="hljs-comment"># 如果 right 比 root 大的话，r&lt;n用于控制调整区间。</span><br>             largest = r<br>         <span class="hljs-keyword">if</span> largest != i:  <span class="hljs-comment"># 说明进行了调整，将堆顶和调整目标进行交换</span><br>             swap(nums, i, largest)<br>             <span class="hljs-comment"># 递归调整子节点，此时largest是left或者right的节点的下标。</span><br>             heapify(nums, n, largest)<br><br>     _len = <span class="hljs-built_in">len</span>(nums)<br><br>     <span class="hljs-comment"># 建立堆</span><br>     <span class="hljs-comment">#  range(n//2-1, -1, -1)是所有非叶子节点。从最后一个非叶子节点开始，使用heapify函数调整，保证根节点数值大于叶子节点数值。</span><br>     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_len // <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):  <span class="hljs-comment"># i就是一个非叶子节点</span><br>         heapify(nums, _len, i)<br><br>     <span class="hljs-comment"># 调整完之后，就建立了一个大根堆，从堆顶（nums[0]）取出元素。</span><br>     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(_len - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):  <span class="hljs-comment"># i用于标记有序区，nums[&gt;i]的部分都是有序区。</span><br>         <span class="hljs-comment"># 一个一个的从堆顶（nums[0]）取出元素，和list无序区最后的元素nums[i]交换。</span><br>         swap(nums, i, <span class="hljs-number">0</span>)<br>         <span class="hljs-comment"># 交换完成之后，从堆顶往下调整，使用i控制调整不会影响有序区。</span><br>         heapify(nums, i, <span class="hljs-number">0</span>)<br><br>     <span class="hljs-keyword">return</span> nums<br></code></pre></div></td></tr></table></figure>
<h2 id="参考链接">参考链接</h2>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57667927">堆的实现及工程应用(Python)</a> https://www.jb51.net/article/87552.htm</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/04/10/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">算法：回溯算法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/04/10/%E5%8A%9B%E6%89%A3-DP%E9%97%AE%E9%A2%98%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB/">
                        <span class="hidden-mobile">[力扣] DP问题分类汇总</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function() {
        this.page.url = 'http://example.com/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9B%BE%E5%92%8C%E5%A0%86/';
        this.page.identifier = '/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%9B%BE%E5%92%8C%E5%A0%86/';
      };
      Fluid.utils.waitElementVisible('disqus_thread', function () {
        var d = document, s = d.createElement('script');
        s.src = '//' + 'codesisart' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', new Date());
        (d.head || d.body).appendChild(s);
      });
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>

<!-- <script type="text/javascript" src="/js/cdnjs.cloudflare.com_ajax_libs_mathjax_2.7.1_MathJax.js_config=TeX-MML-AM_CHTML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->


</body>
</html>
